<?php
/**
 * ObjectSerializer.
 *
 * PHP version 5
 *
 * @category Class
 * @author   Swagger Codegen team
 * @see     https://github.com/swagger-api/swagger-codegen
 */

/**
 * AwardWallet Email Parsing API.
 *
 * Email Parsing API allows you to extract structured information from an unstructured email. Specifically, you can extract travel itineraries from virtually any travel provider using this REST API. The email parser API can automatically process incoming emails, it will extract data from incoming emails and using webhook integrations send the resulting structured data to your endpoint. The main benefit of this email scraping technology is that you can import travel reservations that belong to your users regardless of how these reservations were booked.  Technically here is what happens under the hood: when an email is received for parsing it gets put into a queue for processing, email workers grab emails out of that queue and send them for parsing. The actual process of parsing consists of applying tens of thousands of regular expressions against a given email until the right parser is found and the required data attributes are extracted from that email. Some of our clients have asked us: \"What is the difference between email parsing and email scraping?\" and the answer is: there is no difference, email scraping (or parsing), just like web scraping means retrieving structured format from unstructured text, be that a web page or body of an email. There are usually two ways to do that: (1) to run regular expressions against that body of text or (2) run XPath queries if the text body has proper HTML formatting.   With AwardWallet Email Parsing API you can send any travel itinerary or reservation to our endpoint and the parse API will extract the data and return the reservation data in a structured format (JSON) for your consumption. Parsing is done automatically and takes just a few seconds.  We support thousands of email formats ([click to view the AwardWallet’s list of emails supported for parsing](https://awardwallet.com/supportedEmail)) and we have a dedicated team of developers who constantly work on improving the API by adding new parsers to support new email formats.  If you have an email reservation and want to do a quick test you can upload the .eml file or copy-paste the raw content of the email via our [example test page](https://awardwallet.com/emailTestParse). You should see the parsing results immediately after submitting the request at the bottom of the page.  For production mode, the API is designed to work asynchronously. Here is the workflow diagram explaining what happens to an email once it is received by the API:  <div class=\"diagram-container\"><div class=\"diagram\"></div></div>  At a high level, here is how the API works:   - You submit an email message for parsing, and specify your `callbackUrl ` (must be registered with us prior to using the API) in your request. Our API will respond with a `queued` status. At this point you don’t know if your message was parsed or not.  - Your message will be processed by an automated parser. Shortly, typically within seconds, you will receive a response to your `callbackUrl `, with one of the [`status`](#method-email_Parsing_2) codes (which are described below). In most cases, you should get a `success` code and the results of the parsing will be returned to you in that callback response. For testing, instead of receiving the results to your callback URL, you may simply call the [`/getResults/{requestID}`](#method-email_Parsing_2) method to see the results.   - If you get a `review` status - you should expect a subsequent callback with either `success`, `invalid`, `restricted` or `skipped` status. At this point we are not able to guarantee any time range for manual review process.  - Typically, the emails that you send to us are stored on the AwardWallet’s servers for two weeks (in the Amazon AWS cloud). After that, the emails are permanently deleted from our servers. If it so happens that there will be emails in the `review` status at the two-week mark we will also send you a response to your `callbackUrl` with a status of `timeout` at the time when we purge the emails.  - Every method that we make available as part of this API can be invoked through two endpoints, the ones that have the `-eu` in the URL point to our EU infrastructure, where all the data processing happens inside EU. The other one points to the servers hosted in the US.  - You could use [swagger schema](https://email.awardwallet.com/email/swagger.json) to generate your API clients.
 *
 * OpenAPI spec version: 2.0.0
 *
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.12
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace AwardWallet\MainBundle\Service\EmailParsing\Client;

/**
 * ObjectSerializer Class Doc Comment.
 *
 * @category Class
 * @author   Swagger Codegen team
 * @see     https://github.com/swagger-api/swagger-codegen
 */
class ObjectSerializer
{
    /**
     * Serialize data.
     *
     * @param mixed  $data   the data to serialize
     * @param string $type   the SwaggerType of the data
     * @param string $format the format of the Swagger type of the data
     * @return string|object serialized form of $data
     */
    public static function sanitizeForSerialization($data, $type = null, $format = null)
    {
        if (is_scalar($data) || null === $data) {
            return $data;
        } elseif ($data instanceof \DateTime) {
            return ($format === 'date') ? $data->format('Y-m-d') : $data->format(\DateTime::ATOM);
        } elseif (is_array($data)) {
            foreach ($data as $property => $value) {
                $data[$property] = self::sanitizeForSerialization($value);
            }

            return $data;
        } elseif ($data instanceof \stdClass) {
            foreach ($data as $property => $value) {
                $data->$property = self::sanitizeForSerialization($value);
            }

            return $data;
        } elseif (is_object($data)) {
            $values = [];
            $formats = $data::swaggerFormats();

            foreach ($data::swaggerTypes() as $property => $swaggerType) {
                $getter = $data::getters()[$property];
                $value = $data->$getter();

                if ($value !== null
                    && !in_array($swaggerType, ['DateTime', 'bool', 'boolean', 'byte', 'double', 'float', 'int', 'integer', 'mixed', 'number', 'object', 'string', 'void'], true)
                    && method_exists($swaggerType, 'getAllowableEnumValues')
                    && !in_array($value, $swaggerType::getAllowableEnumValues(), true)) {
                    $imploded = implode("', '", $swaggerType::getAllowableEnumValues());

                    throw new \InvalidArgumentException("Invalid value for enum '$swaggerType', must be one of: '$imploded'");
                }

                if ($value !== null) {
                    $values[$data::attributeMap()[$property]] = self::sanitizeForSerialization($value, $swaggerType, $formats[$property]);
                }
            }

            return (object) $values;
        } else {
            return (string) $data;
        }
    }

    /**
     * Sanitize filename by removing path.
     * e.g. ../../sun.gif becomes sun.gif.
     *
     * @param string $filename filename to be sanitized
     * @return string the sanitized filename
     */
    public static function sanitizeFilename($filename)
    {
        if (preg_match("/.*[\/\\\\](.*)$/", $filename, $match)) {
            return $match[1];
        } else {
            return $filename;
        }
    }

    /**
     * Take value and turn it into a string suitable for inclusion in
     * the path, by url-encoding.
     *
     * @param string $value a string which will be part of the path
     * @return string the serialized object
     */
    public static function toPathValue($value)
    {
        return rawurlencode(self::toString($value));
    }

    /**
     * Take value and turn it into a string suitable for inclusion in
     * the query, by imploding comma-separated if it's an object.
     * If it's a string, pass through unchanged. It will be url-encoded
     * later.
     *
     * @param string[]|string|\DateTime $object an object to be serialized to a string
     * @return string the serialized object
     */
    public static function toQueryValue($object)
    {
        if (is_array($object)) {
            return implode(',', $object);
        } else {
            return self::toString($object);
        }
    }

    /**
     * Take value and turn it into a string suitable for inclusion in
     * the header. If it's a string, pass through unchanged
     * If it's a datetime object, format it in ISO8601.
     *
     * @param string $value a string which will be part of the header
     * @return string the header string
     */
    public static function toHeaderValue($value)
    {
        return self::toString($value);
    }

    /**
     * Take value and turn it into a string suitable for inclusion in
     * the http body (form parameter). If it's a string, pass through unchanged
     * If it's a datetime object, format it in ISO8601.
     *
     * @param string|\SplFileObject $value the value of the form parameter
     * @return string the form string
     */
    public static function toFormValue($value)
    {
        if ($value instanceof \SplFileObject) {
            return $value->getRealPath();
        } else {
            return self::toString($value);
        }
    }

    /**
     * Take value and turn it into a string suitable for inclusion in
     * the parameter. If it's a string, pass through unchanged
     * If it's a datetime object, format it in ISO8601.
     *
     * @param string|\DateTime $value the value of the parameter
     * @return string the header string
     */
    public static function toString($value)
    {
        if ($value instanceof \DateTime) { // datetime in ISO8601 format
            return $value->format(\DateTime::ATOM);
        } else {
            return $value;
        }
    }

    /**
     * Serialize an array to a string.
     *
     * @param array  $collection                 collection to serialize to a string
     * @param string $collectionFormat           the format use for serialization (csv,
     * ssv, tsv, pipes, multi)
     * @param bool   $allowCollectionFormatMulti allow collection format to be a multidimensional array
     * @return string
     */
    public static function serializeCollection(array $collection, $collectionFormat, $allowCollectionFormatMulti = false)
    {
        if ($allowCollectionFormatMulti && ('multi' === $collectionFormat)) {
            // http_build_query() almost does the job for us. We just
            // need to fix the result of multidimensional arrays.
            return preg_replace('/%5B[0-9]+%5D=/', '=', http_build_query($collection, '', '&'));
        }

        switch ($collectionFormat) {
            case 'pipes':
                return implode('|', $collection);

            case 'tsv':
                return implode("\t", $collection);

            case 'ssv':
                return implode(' ', $collection);

            case 'csv':
                // Deliberate fall through. CSV is default format.
            default:
                return implode(',', $collection);
        }
    }

    /**
     * Deserialize a JSON string into an object.
     *
     * @param mixed    $data          object or primitive to be deserialized
     * @param string   $class         class name is passed as a string
     * @param string[] $httpHeaders   HTTP headers
     * @return object|array|null an single or an array of $class instances
     */
    public static function deserialize($data, $class, $httpHeaders = null)
    {
        if (null === $data) {
            return null;
        } elseif (substr($class, 0, 4) === 'map[') { // for associative array e.g. map[string,int]
            $inner = substr($class, 4, -1);
            $deserialized = [];

            if (strrpos($inner, ",") !== false) {
                $subClass_array = explode(',', $inner, 2);
                $subClass = $subClass_array[1];

                foreach ($data as $key => $value) {
                    $deserialized[$key] = self::deserialize($value, $subClass, null);
                }
            }

            return $deserialized;
        } elseif (strcasecmp(substr($class, -2), '[]') === 0) {
            $subClass = substr($class, 0, -2);
            $values = [];

            foreach ($data as $key => $value) {
                $values[] = self::deserialize($value, $subClass, null);
            }

            return $values;
        } elseif ($class === 'object') {
            settype($data, 'array');

            return $data;
        } elseif ($class === '\DateTime') {
            // Some API's return an invalid, empty string as a
            // date-time property. DateTime::__construct() will return
            // the current time for empty input which is probably not
            // what is meant. The invalid empty string is probably to
            // be interpreted as a missing field/value. Let's handle
            // this graceful.
            if (!empty($data)) {
                return new \DateTime($data);
            } else {
                return null;
            }
        } elseif (in_array($class, ['DateTime', 'bool', 'boolean', 'byte', 'double', 'float', 'int', 'integer', 'mixed', 'number', 'object', 'string', 'void'], true)) {
            settype($data, $class);

            return $data;
        } elseif ($class === '\SplFileObject') {
            /** @var \Psr\Http\Message\StreamInterface $data */

            // determine file name
            if (array_key_exists('Content-Disposition', $httpHeaders)
                && preg_match('/inline; filename=[\'"]?([^\'"\s]+)[\'"]?$/i', $httpHeaders['Content-Disposition'], $match)) {
                $filename = Configuration::getDefaultConfiguration()->getTempFolderPath() . DIRECTORY_SEPARATOR . self::sanitizeFilename($match[1]);
            } else {
                $filename = tempnam(Configuration::getDefaultConfiguration()->getTempFolderPath(), '');
            }

            $file = fopen($filename, 'w');

            while ($chunk = $data->read(200)) {
                fwrite($file, $chunk);
            }
            fclose($file);

            return new \SplFileObject($filename, 'r');
        } elseif (method_exists($class, 'getAllowableEnumValues')) {
            if (!in_array($data, $class::getAllowableEnumValues(), true)) {
                $imploded = implode("', '", $class::getAllowableEnumValues());

                throw new \InvalidArgumentException("Invalid value for enum '$class', must be one of: '$imploded'");
            }

            return $data;
        } else {
            // If a discriminator is defined and points to a valid subclass, use it.
            $discriminator = $class::DISCRIMINATOR;

            if (!empty($discriminator) && isset($data->{$discriminator}) && is_string($data->{$discriminator})) {
                $subclass = '\AwardWallet\MainBundle\Service\EmailParsing\Client\Model\\' . $data->{$discriminator};

                if ($data->{$discriminator} == "imap") {
                    $subclass = '\AwardWallet\MainBundle\Service\EmailParsing\Client\Model\ImapMailbox';
                } elseif ($data->{$discriminator} == "google") {
                    $subclass = '\AwardWallet\MainBundle\Service\EmailParsing\Client\Model\GoogleMailbox';
                } elseif ($data->{$discriminator} == "microsoft") {
                    $subclass = '\AwardWallet\MainBundle\Service\EmailParsing\Client\Model\MicrosoftMailbox';
                } elseif ($data->{$discriminator} == "yahoo") {
                    $subclass = '\AwardWallet\MainBundle\Service\EmailParsing\Client\Model\YahooMailbox';
                } elseif ($data->{$discriminator} == "aol") {
                    $subclass = '\AwardWallet\MainBundle\Service\EmailParsing\Client\Model\AolMailbox';
                }

                if (is_subclass_of($subclass, $class)) {
                    $class = $subclass;
                }
            }
            $instance = new $class();

            foreach ($instance::swaggerTypes() as $property => $type) {
                $propertySetter = $instance::setters()[$property];

                if (!isset($propertySetter) || !isset($data->{$instance::attributeMap()[$property]})) {
                    continue;
                }

                $propertyValue = $data->{$instance::attributeMap()[$property]};

                if (isset($propertyValue)) {
                    $instance->$propertySetter(self::deserialize($propertyValue, $type, null));
                }
            }

            return $instance;
        }
    }
}
