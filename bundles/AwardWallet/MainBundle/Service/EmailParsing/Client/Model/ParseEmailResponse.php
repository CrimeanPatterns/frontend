<?php
/**
 * ParseEmailResponse.
 *
 * PHP version 5
 *
 * @category Class
 * @author   Swagger Codegen team
 * @see     https://github.com/swagger-api/swagger-codegen
 */

/**
 * AwardWallet Email Parsing API.
 *
 * Email Parsing API allows you to extract structured information from an unstructured email. Specifically, you can extract travel itineraries from virtually any travel provider using this REST API. The email parser API can automatically process incoming emails, it will extract data from incoming emails and using webhook integrations send the resulting structured data to your endpoint. The main benefit of this email scraping technology is that you can import travel reservations that belong to your users regardless of how these reservations were booked.  Technically here is what happens under the hood: when an email is received for parsing it gets put into a queue for processing, email workers grab emails out of that queue and send them for parsing. The actual process of parsing consists of applying tens of thousands of regular expressions against a given email until the right parser is found and the required data attributes are extracted from that email. Some of our clients have asked us: \"What is the difference between email parsing and email scraping?\" and the answer is: there is no difference, email scraping (or parsing), just like web scraping means retrieving structured format from unstructured text, be that a web page or body of an email. There are usually two ways to do that: (1) to run regular expressions against that body of text or (2) run XPath queries if the text body has proper HTML formatting.   With AwardWallet Email Parsing API you can send any travel itinerary or reservation to our endpoint and the parse API will extract the data and return the reservation data in a structured format (JSON) for your consumption. Parsing is done automatically and takes just a few seconds.  We support thousands of email formats ([click to view the AwardWallet’s list of emails supported for parsing](https://awardwallet.com/supportedEmail)) and we have a dedicated team of developers who constantly work on improving the API by adding new parsers to support new email formats.  If you have an email reservation and want to do a quick test you can upload the .eml file or copy-paste the raw content of the email via our [example test page](https://awardwallet.com/emailTestParse). You should see the parsing results immediately after submitting the request at the bottom of the page.  For production mode, the API is designed to work asynchronously. Here is the workflow diagram explaining what happens to an email once it is received by the API:  <div class=\"diagram-container\"><div class=\"diagram\"></div></div>  At a high level, here is how the API works:   - You submit an email message for parsing, and specify your `callbackUrl ` (must be registered with us prior to using the API) in your request. Our API will respond with a `queued` status. At this point you don’t know if your message was parsed or not.  - Your message will be processed by an automated parser. Shortly, typically within seconds, you will receive a response to your `callbackUrl `, with one of the [`status`](#method-email_Parsing_2) codes (which are described below). In most cases, you should get a `success` code and the results of the parsing will be returned to you in that callback response. For testing, instead of receiving the results to your callback URL, you may simply call the [`/getResults/{requestID}`](#method-email_Parsing_2) method to see the results.   - If you get a `review` status - you should expect a subsequent callback with either `success`, `invalid`, `restricted` or `skipped` status. At this point we are not able to guarantee any time range for manual review process.  - Typically, the emails that you send to us are stored on the AwardWallet’s servers for two weeks (in the Amazon AWS cloud). After that, the emails are permanently deleted from our servers. If it so happens that there will be emails in the `review` status at the two-week mark we will also send you a response to your `callbackUrl` with a status of `timeout` at the time when we purge the emails.  - Every method that we make available as part of this API can be invoked through two endpoints, the ones that have the `-eu` in the URL point to our EU infrastructure, where all the data processing happens inside EU. The other one points to the servers hosted in the US.  - You could use [swagger schema](https://email.awardwallet.com/email/swagger.json) to generate your API clients.
 *
 * OpenAPI spec version: 2.0.0
 *
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.12
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace AwardWallet\MainBundle\Service\EmailParsing\Client\Model;

use AwardWallet\MainBundle\Service\EmailParsing\Client\ObjectSerializer;

/**
 * ParseEmailResponse Class Doc Comment.
 *
 * @category Class
 * @author   Swagger Codegen team
 * @see     https://github.com/swagger-api/swagger-codegen
 */
class ParseEmailResponse implements ModelInterface, \ArrayAccess
{
    public const DISCRIMINATOR = null;

    public const STATUS_SUCCESS = 'success';
    public const STATUS_QUEUED = 'queued';
    public const STATUS_INVALID = 'invalid';
    public const STATUS_REVIEW = 'review';
    public const STATUS_RESTRICTED = 'restricted';
    public const STATUS_SKIPPED = 'skipped';
    public const STATUS_TIMEOUT = 'timeout';
    public const REJECT_METHOD_AUTO = 'auto';
    public const REJECT_METHOD_MANUAL = 'manual';
    public const REJECT_METHOD_INCOMPLETE = 'incomplete';
    public const PARSING_METHOD_AUTO = 'auto';
    public const PARSING_METHOD_MANUAL = 'manual';

    /**
     * The original name of the model.
     *
     * @var string
     */
    protected static $swaggerModelName = 'ParseEmailResponse';

    /**
     * Array of property to type mappings. Used for (de)serialization.
     *
     * @var string[]
     */
    protected static $swaggerTypes = [
        'apiVersion' => 'string',
        'requestId' => 'string',
        'status' => 'string',
        'statusMessage' => 'string',
        'rejectMethod' => 'string',
        'missingFields' => 'string[]',
        'providerCode' => 'string',
        'fromProvider' => 'bool',
        'loyaltyAccount' => '\AwardWallet\MainBundle\Service\EmailParsing\Client\Model\LoyaltyAccount',
        'itineraries' => '\AwardWallet\MainBundle\Service\EmailParsing\Client\Model\ItineraryCommon',
        'email' => 'string',
        'metadata' => '\AwardWallet\MainBundle\Service\EmailParsing\Client\Model\EmailInfo',
        'nestedEmailMetadata' => '\AwardWallet\MainBundle\Service\EmailParsing\Client\Model\EmailInfo',
        'pricingInfo' => '\AwardWallet\MainBundle\Service\EmailParsing\Client\Model\PricingInfo',
        'parsingMethod' => 'string',
        'flightStatsMethodsUsed' => 'object[]',
        'userData' => 'string',
    ];

    /**
     * Array of property to format mappings. Used for (de)serialization.
     *
     * @var string[]
     */
    protected static $swaggerFormats = [
        'apiVersion' => null,
        'requestId' => null,
        'status' => null,
        'statusMessage' => null,
        'rejectMethod' => null,
        'missingFields' => null,
        'providerCode' => null,
        'fromProvider' => null,
        'loyaltyAccount' => null,
        'itineraries' => null,
        'email' => null,
        'metadata' => null,
        'nestedEmailMetadata' => null,
        'pricingInfo' => null,
        'parsingMethod' => null,
        'flightStatsMethodsUsed' => null,
        'userData' => null,
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name.
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'apiVersion' => 'apiVersion',
        'requestId' => 'requestId',
        'status' => 'status',
        'statusMessage' => 'statusMessage',
        'rejectMethod' => 'rejectMethod',
        'missingFields' => 'missingFields',
        'providerCode' => 'providerCode',
        'fromProvider' => 'fromProvider',
        'loyaltyAccount' => 'loyaltyAccount',
        'itineraries' => 'itineraries',
        'email' => 'email',
        'metadata' => 'metadata',
        'nestedEmailMetadata' => 'nestedEmailMetadata',
        'pricingInfo' => 'pricingInfo',
        'parsingMethod' => 'parsingMethod',
        'flightStatsMethodsUsed' => 'flightStatsMethodsUsed',
        'userData' => 'userData',
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses).
     *
     * @var string[]
     */
    protected static $setters = [
        'apiVersion' => 'setApiVersion',
        'requestId' => 'setRequestId',
        'status' => 'setStatus',
        'statusMessage' => 'setStatusMessage',
        'rejectMethod' => 'setRejectMethod',
        'missingFields' => 'setMissingFields',
        'providerCode' => 'setProviderCode',
        'fromProvider' => 'setFromProvider',
        'loyaltyAccount' => 'setLoyaltyAccount',
        'itineraries' => 'setItineraries',
        'email' => 'setEmail',
        'metadata' => 'setMetadata',
        'nestedEmailMetadata' => 'setNestedEmailMetadata',
        'pricingInfo' => 'setPricingInfo',
        'parsingMethod' => 'setParsingMethod',
        'flightStatsMethodsUsed' => 'setFlightStatsMethodsUsed',
        'userData' => 'setUserData',
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests).
     *
     * @var string[]
     */
    protected static $getters = [
        'apiVersion' => 'getApiVersion',
        'requestId' => 'getRequestId',
        'status' => 'getStatus',
        'statusMessage' => 'getStatusMessage',
        'rejectMethod' => 'getRejectMethod',
        'missingFields' => 'getMissingFields',
        'providerCode' => 'getProviderCode',
        'fromProvider' => 'getFromProvider',
        'loyaltyAccount' => 'getLoyaltyAccount',
        'itineraries' => 'getItineraries',
        'email' => 'getEmail',
        'metadata' => 'getMetadata',
        'nestedEmailMetadata' => 'getNestedEmailMetadata',
        'pricingInfo' => 'getPricingInfo',
        'parsingMethod' => 'getParsingMethod',
        'flightStatsMethodsUsed' => 'getFlightStatsMethodsUsed',
        'userData' => 'getUserData',
    ];

    /**
     * Associative array for storing property values.
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor.
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(?array $data = null)
    {
        $this->container['apiVersion'] = $data['apiVersion'] ?? null;
        $this->container['requestId'] = $data['requestId'] ?? null;
        $this->container['status'] = $data['status'] ?? null;
        $this->container['statusMessage'] = $data['statusMessage'] ?? null;
        $this->container['rejectMethod'] = $data['rejectMethod'] ?? null;
        $this->container['missingFields'] = $data['missingFields'] ?? null;
        $this->container['providerCode'] = $data['providerCode'] ?? null;
        $this->container['fromProvider'] = $data['fromProvider'] ?? null;
        $this->container['loyaltyAccount'] = $data['loyaltyAccount'] ?? null;
        $this->container['itineraries'] = $data['itineraries'] ?? null;
        $this->container['email'] = $data['email'] ?? null;
        $this->container['metadata'] = $data['metadata'] ?? null;
        $this->container['nestedEmailMetadata'] = $data['nestedEmailMetadata'] ?? null;
        $this->container['pricingInfo'] = $data['pricingInfo'] ?? null;
        $this->container['parsingMethod'] = $data['parsingMethod'] ?? null;
        $this->container['flightStatsMethodsUsed'] = $data['flightStatsMethodsUsed'] ?? null;
        $this->container['userData'] = $data['userData'] ?? null;
    }

    /**
     * Gets the string presentation of the object.
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }

    /**
     * Array of property to type mappings. Used for (de)serialization.
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization.
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name.
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses).
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests).
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    /**
     * Gets allowable values of the enum.
     *
     * @return string[]
     */
    public function getStatusAllowableValues()
    {
        return [
            self::STATUS_SUCCESS,
            self::STATUS_QUEUED,
            self::STATUS_INVALID,
            self::STATUS_REVIEW,
            self::STATUS_RESTRICTED,
            self::STATUS_SKIPPED,
            self::STATUS_TIMEOUT,
        ];
    }

    /**
     * Gets allowable values of the enum.
     *
     * @return string[]
     */
    public function getRejectMethodAllowableValues()
    {
        return [
            self::REJECT_METHOD_AUTO,
            self::REJECT_METHOD_MANUAL,
            self::REJECT_METHOD_INCOMPLETE,
        ];
    }

    /**
     * Gets allowable values of the enum.
     *
     * @return string[]
     */
    public function getParsingMethodAllowableValues()
    {
        return [
            self::PARSING_METHOD_AUTO,
            self::PARSING_METHOD_MANUAL,
        ];
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['apiVersion'] === null) {
            $invalidProperties[] = "'apiVersion' can't be null";
        }

        if ($this->container['requestId'] === null) {
            $invalidProperties[] = "'requestId' can't be null";
        }

        if ($this->container['status'] === null) {
            $invalidProperties[] = "'status' can't be null";
        }
        $allowedValues = $this->getStatusAllowableValues();

        if (!is_null($this->container['status']) && !in_array($this->container['status'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'status', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getRejectMethodAllowableValues();

        if (!is_null($this->container['rejectMethod']) && !in_array($this->container['rejectMethod'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'rejectMethod', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['metadata'] === null) {
            $invalidProperties[] = "'metadata' can't be null";
        }
        $allowedValues = $this->getParsingMethodAllowableValues();

        if (!is_null($this->container['parsingMethod']) && !in_array($this->container['parsingMethod'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'parsingMethod', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed.
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }

    /**
     * Gets apiVersion.
     *
     * @return string
     */
    public function getApiVersion()
    {
        return $this->container['apiVersion'];
    }

    /**
     * Sets apiVersion.
     *
     * @param string $apiVersion version of the API being used
     * @return $this
     */
    public function setApiVersion($apiVersion)
    {
        $this->container['apiVersion'] = $apiVersion;

        return $this;
    }

    /**
     * Gets requestId.
     *
     * @return string
     */
    public function getRequestId()
    {
        return $this->container['requestId'];
    }

    /**
     * Sets requestId.
     *
     * @param string $requestId requestID that corresponds to this email
     * @return $this
     */
    public function setRequestId($requestId)
    {
        $this->container['requestId'] = $requestId;

        return $this;
    }

    /**
     * Gets status.
     *
     * @return string
     */
    public function getStatus()
    {
        return $this->container['status'];
    }

    /**
     * Sets status.
     *
     * @param string $status Status of the parsing results. The possible values are:  **success** - The email was successfully parsed  **queued** - The email is sitting in the queue, waiting to be processed by the parser you can call this method again in a few seconds or you can wait to receive the results to the `callbackUrl` that you specified.  **invalid** - It was determined that this email does not contain a valid travel itinerary or reservation. See the `statusMessage` for more details.  **review** - The automated parsers failed to parse this email, at this point the message is going to be placed into the manual queue for someone at AwardWallet to check it and decide if we should adjust a parser and re-run it again through the parsing process. You should not expect successful parsing results quickly (in under 1 hour) as someone manually has to review the email and adjust the parsers.  **restricted**  - This is a restricted provider that AwardWallet is not allowed to parse at this point.  **skipped** - This email was reviewed and we determined that this is an itinerary and for one reason or another we did not parse this reservation. This email was not counted against your license count.  **timeout** - We were not able to review this email in a timely fashion, thus we don’t know if this is a valid reservation or not. This email was purged from our queue automatically and was not counted against your license count.
     * @return $this
     */
    public function setStatus($status)
    {
        $allowedValues = $this->getStatusAllowableValues();

        if (!in_array($status, $allowedValues, true)) {
            throw new \InvalidArgumentException(sprintf("Invalid value for 'status', must be one of '%s'", implode("', '", $allowedValues)));
        }
        $this->container['status'] = $status;

        return $this;
    }

    /**
     * Gets statusMessage.
     *
     * @return string
     */
    public function getStatusMessage()
    {
        return $this->container['statusMessage'];
    }

    /**
     * Sets statusMessage.
     *
     * @param string $statusMessage if you get `invalid` as the returned value in the `status` field, this field will have additional information for you
     * @return $this
     */
    public function setStatusMessage($statusMessage)
    {
        $this->container['statusMessage'] = $statusMessage;

        return $this;
    }

    /**
     * Gets rejectMethod.
     *
     * @return string
     */
    public function getRejectMethod()
    {
        return $this->container['rejectMethod'];
    }

    /**
     * Sets rejectMethod.
     *
     * @param string $rejectMethod This field indicates the reason why our system determined that an email does not contain a valid travel reservation in it. The possible values are:  **auto** - The system automatically (using built-in filters) determined that the email does not contain a valid itinerary.  **manual** - This email was reviewed by our support staff and it was determined that it does not contain a valid travel reservation.  **incomplete** - This email might contain a travel reservation, but some required fields are missing from it.
     * @return $this
     */
    public function setRejectMethod($rejectMethod)
    {
        $allowedValues = $this->getRejectMethodAllowableValues();

        if (!is_null($rejectMethod) && !in_array($rejectMethod, $allowedValues, true)) {
            throw new \InvalidArgumentException(sprintf("Invalid value for 'rejectMethod', must be one of '%s'", implode("', '", $allowedValues)));
        }
        $this->container['rejectMethod'] = $rejectMethod;

        return $this;
    }

    /**
     * Gets missingFields.
     *
     * @return string[]
     */
    public function getMissingFields()
    {
        return $this->container['missingFields'];
    }

    /**
     * Sets missingFields.
     *
     * @param string[] $missingFields If the `rejectMethod` field returns the `incomplete` value, this field will return an array of names of missing fields. For example if `segments.arrival.airportCode` is a required field and is missing in the email, this value will be returned here, so you know exactly why this email failed to parse.
     * @return $this
     */
    public function setMissingFields($missingFields)
    {
        $this->container['missingFields'] = $missingFields;

        return $this;
    }

    /**
     * Gets providerCode.
     *
     * @return string
     */
    public function getProviderCode()
    {
        return $this->container['providerCode'];
    }

    /**
     * Sets providerCode.
     *
     * @param string $providerCode alpha-numeric value with no spaces that uniquely identifies any given provider within the AwardWallet interface
     * @return $this
     */
    public function setProviderCode($providerCode)
    {
        $this->container['providerCode'] = $providerCode;

        return $this;
    }

    /**
     * Gets fromProvider.
     *
     * @return bool
     */
    public function getFromProvider()
    {
        return $this->container['fromProvider'];
    }

    /**
     * Sets fromProvider.
     *
     * @param bool $fromProvider indicates if this email was sent directly by the provider as opposed to the user forwarding that message
     * @return $this
     */
    public function setFromProvider($fromProvider)
    {
        $this->container['fromProvider'] = $fromProvider;

        return $this;
    }

    /**
     * Gets loyaltyAccount.
     *
     * @return \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\LoyaltyAccount
     */
    public function getLoyaltyAccount()
    {
        return $this->container['loyaltyAccount'];
    }

    /**
     * Sets loyaltyAccount.
     *
     * @param \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\LoyaltyAccount $loyaltyAccount If the email contains loyalty information (i.e. account balance, account number, elite status, etc.) like a monthly statement, then we will return all that loyalty information in this object. We typically do this for United, Delta and Southwest statements.
     * @return $this
     */
    public function setLoyaltyAccount($loyaltyAccount)
    {
        $this->container['loyaltyAccount'] = $loyaltyAccount;

        return $this;
    }

    /**
     * Gets itineraries.
     *
     * @return \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\ItineraryCommon
     */
    public function getItineraries()
    {
        return $this->container['itineraries'];
    }

    /**
     * Sets itineraries.
     *
     * @param \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\ItineraryCommon $itineraries An array of all itineraries parsed out of the email
     * @return $this
     */
    public function setItineraries($itineraries)
    {
        $this->container['itineraries'] = $itineraries;

        return $this;
    }

    /**
     * Gets email.
     *
     * @return string
     */
    public function getEmail()
    {
        return $this->container['email'];
    }

    /**
     * Sets email.
     *
     * @param string $email Returns the email headers, the entire email, or nothing at all, depending on the value of  `returnEmail` parameter in [the request](#method-email_Parsing_1). The value is be base64 encoded.
     * @return $this
     */
    public function setEmail($email)
    {
        $this->container['email'] = $email;

        return $this;
    }

    /**
     * Gets metadata.
     *
     * @return \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\EmailInfo
     */
    public function getMetadata()
    {
        return $this->container['metadata'];
    }

    /**
     * Sets metadata.
     *
     * @param \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\EmailInfo $metadata Some email headers and other metadata will be returned in this object. If you need to get the full headers, please set the `returnEmail` attribute to `headers` and you will get them via the `email` attribute.
     * @return $this
     */
    public function setMetadata($metadata)
    {
        $this->container['metadata'] = $metadata;

        return $this;
    }

    /**
     * Gets nestedEmailMetadata.
     *
     * @return \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\EmailInfo
     */
    public function getNestedEmailMetadata()
    {
        return $this->container['nestedEmailMetadata'];
    }

    /**
     * Sets nestedEmailMetadata.
     *
     * @param \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\EmailInfo $nestedEmailMetadata Same as the `metadata` attribute above, except `nestedEmailMetadata` is present only when the `metadata.nested` attribute is set to true. It means that this email was received as an attachment to another email that was submitted to us. In that case, the `metadata` field will contain the headers of the parent email (the one that was actually submitted to the API) and this `nestedEmailMetadata` field will contain the headers of the nested email, which parsing results are actually presented in this response.
     * @return $this
     */
    public function setNestedEmailMetadata($nestedEmailMetadata)
    {
        $this->container['nestedEmailMetadata'] = $nestedEmailMetadata;

        return $this;
    }

    /**
     * Gets pricingInfo.
     *
     * @return \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\PricingInfo
     */
    public function getPricingInfo()
    {
        return $this->container['pricingInfo'];
    }

    /**
     * Sets pricingInfo.
     *
     * @param \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\PricingInfo $pricingInfo An object that describes what was paid for this reservation, i.e. fees, taxes, miles, points, etc.
     * @return $this
     */
    public function setPricingInfo($pricingInfo)
    {
        $this->container['pricingInfo'] = $pricingInfo;

        return $this;
    }

    /**
     * Gets parsingMethod.
     *
     * @return string
     */
    public function getParsingMethod()
    {
        return $this->container['parsingMethod'];
    }

    /**
     * Sets parsingMethod.
     *
     * @param string $parsingMethod The method of parsing that was used. There are two possible values:    **auto** - for automatically parsed emails    **manual** – for emails that were parsed manually by the AwardWallet team
     * @return $this
     */
    public function setParsingMethod($parsingMethod)
    {
        $allowedValues = $this->getParsingMethodAllowableValues();

        if (!is_null($parsingMethod) && !in_array($parsingMethod, $allowedValues, true)) {
            throw new \InvalidArgumentException(sprintf("Invalid value for 'parsingMethod', must be one of '%s'", implode("', '", $allowedValues)));
        }
        $this->container['parsingMethod'] = $parsingMethod;

        return $this;
    }

    /**
     * Gets flightStatsMethodsUsed.
     *
     * @return object[]
     */
    public function getFlightStatsMethodsUsed()
    {
        return $this->container['flightStatsMethodsUsed'];
    }

    /**
     * Sets flightStatsMethodsUsed.
     *
     * @param object[] $flightStatsMethodsUsed if we needed to call FlightStats to retrieve some fields that are required and are missing in the email all such FlightStats calls will be listed in this array
     * @return $this
     */
    public function setFlightStatsMethodsUsed($flightStatsMethodsUsed)
    {
        $this->container['flightStatsMethodsUsed'] = $flightStatsMethodsUsed;

        return $this;
    }

    /**
     * Gets userData.
     *
     * @return string
     */
    public function getUserData()
    {
        return $this->container['userData'];
    }

    /**
     * Sets userData.
     *
     * @param string $userData returns whatever text you sent (as is) in the `userData` attribute when you created the request
     * @return $this
     */
    public function setUserData($userData)
    {
        $this->container['userData'] = $userData;

        return $this;
    }

    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param int $offset Offset
     * @return bool
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param int $offset Offset
     */
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int $offset Offset
     * @param mixed   $value  Value to be set
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param int $offset Offset
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }
}
