<?php
/**
 * EmailScannerApi
 * PHP version 5
 *
 * @category Class
 * @package  AwardWallet\MainBundle\Service\EmailParsing\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * AwardWallet Email Parsing API
 *
 * Email Parsing API allows you to extract structured information from an unstructured email. Specifically, you can extract travel itineraries from virtually any travel provider using this REST API. The email parser API can automatically process incoming emails, it will extract data from incoming emails and using webhook integrations send the resulting structured data to your endpoint. The main benefit of this email scraping technology is that you can import travel reservations that belong to your users regardless of how these reservations were booked.  Technically here is what happens under the hood: when an email is received for parsing it gets put into a queue for processing, email workers grab emails out of that queue and send them for parsing. The actual process of parsing consists of applying tens of thousands of regular expressions against a given email until the right parser is found and the required data attributes are extracted from that email. Some of our clients have asked us: \"What is the difference between email parsing and email scraping?\" and the answer is: there is no difference, email scraping (or parsing), just like web scraping means retrieving structured format from unstructured text, be that a web page or body of an email. There are usually two ways to do that: (1) to run regular expressions against that body of text or (2) run XPath queries if the text body has proper HTML formatting.   With AwardWallet Email Parsing API you can send any travel itinerary or reservation to our endpoint and the parse API will extract the data and return the reservation data in a structured format (JSON) for your consumption. Parsing is done automatically and takes just a few seconds.  We support thousands of email formats ([click to view the AwardWallet’s list of emails supported for parsing](https://awardwallet.com/supportedEmail)) and we have a dedicated team of developers who constantly work on improving the API by adding new parsers to support new email formats.  If you have an email reservation and want to do a quick test you can upload the .eml file or copy-paste the raw content of the email via our [example test page](https://awardwallet.com/emailTestParse). You should see the parsing results immediately after submitting the request at the bottom of the page.  For production mode, the API is designed to work asynchronously. Here is the workflow diagram explaining what happens to an email once it is received by the API:  <div class=\"diagram-container\"><div class=\"diagram\"></div></div>  At a high level, here is how the API works:   - You submit an email message for parsing, and specify your `callbackUrl ` (must be registered with us prior to using the API) in your request. Our API will respond with a `queued` status. At this point you don’t know if your message was parsed or not.  - Your message will be processed by an automated parser. Shortly, typically within seconds, you will receive a response to your `callbackUrl `, with one of the [`status`](#method-email_Parsing_2) codes (which are described below). In most cases, you should get a `success` code and the results of the parsing will be returned to you in that callback response. For testing, instead of receiving the results to your callback URL, you may simply call the [`/getResults/{requestID}`](#method-email_Parsing_2) method to see the results.   - If you get a `review` status - you should expect a subsequent callback with either `success`, `invalid`, `restricted` or `skipped` status. At this point we are not able to guarantee any time range for manual review process.  - Typically, the emails that you send to us are stored on the AwardWallet’s servers for two weeks (in the Amazon AWS cloud). After that, the emails are permanently deleted from our servers. If it so happens that there will be emails in the `review` status at the two-week mark we will also send you a response to your `callbackUrl` with a status of `timeout` at the time when we purge the emails.  - Every method that we make available as part of this API can be invoked through two endpoints, the ones that have the `-eu` in the URL point to our EU infrastructure, where all the data processing happens inside EU. The other one points to the servers hosted in the US.  - You could use [swagger schema](https://email.awardwallet.com/email/swagger.json) to generate your API clients.
 *
 * OpenAPI spec version: 2.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.12
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace AwardWallet\MainBundle\Service\EmailParsing\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use AwardWallet\MainBundle\Service\EmailParsing\Client\ApiException;
use AwardWallet\MainBundle\Service\EmailParsing\Client\Configuration;
use AwardWallet\MainBundle\Service\EmailParsing\Client\HeaderSelector;
use AwardWallet\MainBundle\Service\EmailParsing\Client\ObjectSerializer;

/**
 * EmailScannerApi Class Doc Comment
 *
 * @category Class
 * @package  AwardWallet\MainBundle\Service\EmailParsing\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class EmailScannerApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation authMailbox
     *
     * User OAuth Redirect
     *
     * @param  object $code code (required)
     *
     * @throws \AwardWallet\MainBundle\Service\EmailParsing\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function authMailbox($code)
    {
        $this->authMailboxWithHttpInfo($code);
    }

    /**
     * Operation authMailboxWithHttpInfo
     *
     * User OAuth Redirect
     *
     * @param  object $code (required)
     *
     * @throws \AwardWallet\MainBundle\Service\EmailParsing\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function authMailboxWithHttpInfo($code)
    {
        $returnType = '';
        $request = $this->authMailboxRequest($code);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation authMailboxAsync
     *
     * User OAuth Redirect
     *
     * @param  object $code (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function authMailboxAsync($code)
    {
        return $this->authMailboxAsyncWithHttpInfo($code)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation authMailboxAsyncWithHttpInfo
     *
     * User OAuth Redirect
     *
     * @param  object $code (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function authMailboxAsyncWithHttpInfo($code)
    {
        $returnType = '';
        $request = $this->authMailboxRequest($code);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'authMailbox'
     *
     * @param  object $code (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function authMailboxRequest($code)
    {
        // verify the required parameter 'code' is set
        if ($code === null || (is_array($code) && count($code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $code when calling authMailbox'
            );
        }

        $resourcePath = '/v2/mailboxes/auth/{code}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($code !== null) {
            $resourcePath = str_replace(
                '{' . 'code' . '}',
                ObjectSerializer::toPathValue($code),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation connectAolMailbox
     *
     * Connect via Aol API
     *
     * @param  \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\ConnectOAuthMailboxRequest $request request (required)
     *
     * @throws \AwardWallet\MainBundle\Service\EmailParsing\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\AolMailbox
     */
    public function connectAolMailbox($request)
    {
        list($response) = $this->connectAolMailboxWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation connectAolMailboxWithHttpInfo
     *
     * Connect via Aol API
     *
     * @param  \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\ConnectOAuthMailboxRequest $request (required)
     *
     * @throws \AwardWallet\MainBundle\Service\EmailParsing\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\AolMailbox, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectAolMailboxWithHttpInfo($request)
    {
        $returnType = '\AwardWallet\MainBundle\Service\EmailParsing\Client\Model\AolMailbox';
        $request = $this->connectAolMailboxRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AwardWallet\MainBundle\Service\EmailParsing\Client\Model\AolMailbox',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation connectAolMailboxAsync
     *
     * Connect via Aol API
     *
     * @param  \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\ConnectOAuthMailboxRequest $request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function connectAolMailboxAsync($request)
    {
        return $this->connectAolMailboxAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation connectAolMailboxAsyncWithHttpInfo
     *
     * Connect via Aol API
     *
     * @param  \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\ConnectOAuthMailboxRequest $request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function connectAolMailboxAsyncWithHttpInfo($request)
    {
        $returnType = '\AwardWallet\MainBundle\Service\EmailParsing\Client\Model\AolMailbox';
        $request = $this->connectAolMailboxRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'connectAolMailbox'
     *
     * @param  \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\ConnectOAuthMailboxRequest $request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function connectAolMailboxRequest($request)
    {
        // verify the required parameter 'request' is set
        if ($request === null || (is_array($request) && count($request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request when calling connectAolMailbox'
            );
        }

        $resourcePath = '/json/v2/mailboxes/connect/aol';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Authentication');
        if ($apiKey !== null) {
            $headers['X-Authentication'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation connectGoogleMailbox
     *
     * Connect via Google API
     *
     * @param  \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\ConnectOAuthMailboxRequest $request request (required)
     *
     * @throws \AwardWallet\MainBundle\Service\EmailParsing\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\GoogleMailbox
     */
    public function connectGoogleMailbox($request)
    {
        list($response) = $this->connectGoogleMailboxWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation connectGoogleMailboxWithHttpInfo
     *
     * Connect via Google API
     *
     * @param  \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\ConnectOAuthMailboxRequest $request (required)
     *
     * @throws \AwardWallet\MainBundle\Service\EmailParsing\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\GoogleMailbox, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectGoogleMailboxWithHttpInfo($request)
    {
        $returnType = '\AwardWallet\MainBundle\Service\EmailParsing\Client\Model\GoogleMailbox';
        $request = $this->connectGoogleMailboxRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AwardWallet\MainBundle\Service\EmailParsing\Client\Model\GoogleMailbox',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation connectGoogleMailboxAsync
     *
     * Connect via Google API
     *
     * @param  \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\ConnectOAuthMailboxRequest $request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function connectGoogleMailboxAsync($request)
    {
        return $this->connectGoogleMailboxAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation connectGoogleMailboxAsyncWithHttpInfo
     *
     * Connect via Google API
     *
     * @param  \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\ConnectOAuthMailboxRequest $request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function connectGoogleMailboxAsyncWithHttpInfo($request)
    {
        $returnType = '\AwardWallet\MainBundle\Service\EmailParsing\Client\Model\GoogleMailbox';
        $request = $this->connectGoogleMailboxRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'connectGoogleMailbox'
     *
     * @param  \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\ConnectOAuthMailboxRequest $request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function connectGoogleMailboxRequest($request)
    {
        // verify the required parameter 'request' is set
        if ($request === null || (is_array($request) && count($request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request when calling connectGoogleMailbox'
            );
        }

        $resourcePath = '/json/v2/mailboxes/connect/google';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Authentication');
        if ($apiKey !== null) {
            $headers['X-Authentication'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation connectImapMailbox
     *
     * Connect via IMAP
     *
     * @param  \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\ConnectImapMailboxRequest $request request (required)
     *
     * @throws \AwardWallet\MainBundle\Service\EmailParsing\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\ImapMailbox
     */
    public function connectImapMailbox($request)
    {
        list($response) = $this->connectImapMailboxWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation connectImapMailboxWithHttpInfo
     *
     * Connect via IMAP
     *
     * @param  \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\ConnectImapMailboxRequest $request (required)
     *
     * @throws \AwardWallet\MainBundle\Service\EmailParsing\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\ImapMailbox, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectImapMailboxWithHttpInfo($request)
    {
        $returnType = '\AwardWallet\MainBundle\Service\EmailParsing\Client\Model\ImapMailbox';
        $request = $this->connectImapMailboxRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AwardWallet\MainBundle\Service\EmailParsing\Client\Model\ImapMailbox',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation connectImapMailboxAsync
     *
     * Connect via IMAP
     *
     * @param  \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\ConnectImapMailboxRequest $request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function connectImapMailboxAsync($request)
    {
        return $this->connectImapMailboxAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation connectImapMailboxAsyncWithHttpInfo
     *
     * Connect via IMAP
     *
     * @param  \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\ConnectImapMailboxRequest $request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function connectImapMailboxAsyncWithHttpInfo($request)
    {
        $returnType = '\AwardWallet\MainBundle\Service\EmailParsing\Client\Model\ImapMailbox';
        $request = $this->connectImapMailboxRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'connectImapMailbox'
     *
     * @param  \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\ConnectImapMailboxRequest $request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function connectImapMailboxRequest($request)
    {
        // verify the required parameter 'request' is set
        if ($request === null || (is_array($request) && count($request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request when calling connectImapMailbox'
            );
        }

        $resourcePath = '/json/v2/mailboxes/connect/imap';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Authentication');
        if ($apiKey !== null) {
            $headers['X-Authentication'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation connectMicrosoftMailbox
     *
     * Connect via Microsoft API
     *
     * @param  \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\ConnectOAuthMailboxRequest $request request (required)
     *
     * @throws \AwardWallet\MainBundle\Service\EmailParsing\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\MicrosoftMailbox
     */
    public function connectMicrosoftMailbox($request)
    {
        list($response) = $this->connectMicrosoftMailboxWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation connectMicrosoftMailboxWithHttpInfo
     *
     * Connect via Microsoft API
     *
     * @param  \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\ConnectOAuthMailboxRequest $request (required)
     *
     * @throws \AwardWallet\MainBundle\Service\EmailParsing\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\MicrosoftMailbox, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectMicrosoftMailboxWithHttpInfo($request)
    {
        $returnType = '\AwardWallet\MainBundle\Service\EmailParsing\Client\Model\MicrosoftMailbox';
        $request = $this->connectMicrosoftMailboxRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AwardWallet\MainBundle\Service\EmailParsing\Client\Model\MicrosoftMailbox',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation connectMicrosoftMailboxAsync
     *
     * Connect via Microsoft API
     *
     * @param  \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\ConnectOAuthMailboxRequest $request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function connectMicrosoftMailboxAsync($request)
    {
        return $this->connectMicrosoftMailboxAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation connectMicrosoftMailboxAsyncWithHttpInfo
     *
     * Connect via Microsoft API
     *
     * @param  \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\ConnectOAuthMailboxRequest $request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function connectMicrosoftMailboxAsyncWithHttpInfo($request)
    {
        $returnType = '\AwardWallet\MainBundle\Service\EmailParsing\Client\Model\MicrosoftMailbox';
        $request = $this->connectMicrosoftMailboxRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'connectMicrosoftMailbox'
     *
     * @param  \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\ConnectOAuthMailboxRequest $request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function connectMicrosoftMailboxRequest($request)
    {
        // verify the required parameter 'request' is set
        if ($request === null || (is_array($request) && count($request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request when calling connectMicrosoftMailbox'
            );
        }

        $resourcePath = '/json/v2/mailboxes/connect/microsoft';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Authentication');
        if ($apiKey !== null) {
            $headers['X-Authentication'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation connectYahooMailbox
     *
     * Connect via Yahoo API
     *
     * @param  \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\ConnectOAuthMailboxRequest $request request (required)
     *
     * @throws \AwardWallet\MainBundle\Service\EmailParsing\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\YahooMailbox
     */
    public function connectYahooMailbox($request)
    {
        list($response) = $this->connectYahooMailboxWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation connectYahooMailboxWithHttpInfo
     *
     * Connect via Yahoo API
     *
     * @param  \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\ConnectOAuthMailboxRequest $request (required)
     *
     * @throws \AwardWallet\MainBundle\Service\EmailParsing\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\YahooMailbox, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectYahooMailboxWithHttpInfo($request)
    {
        $returnType = '\AwardWallet\MainBundle\Service\EmailParsing\Client\Model\YahooMailbox';
        $request = $this->connectYahooMailboxRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AwardWallet\MainBundle\Service\EmailParsing\Client\Model\YahooMailbox',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation connectYahooMailboxAsync
     *
     * Connect via Yahoo API
     *
     * @param  \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\ConnectOAuthMailboxRequest $request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function connectYahooMailboxAsync($request)
    {
        return $this->connectYahooMailboxAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation connectYahooMailboxAsyncWithHttpInfo
     *
     * Connect via Yahoo API
     *
     * @param  \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\ConnectOAuthMailboxRequest $request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function connectYahooMailboxAsyncWithHttpInfo($request)
    {
        $returnType = '\AwardWallet\MainBundle\Service\EmailParsing\Client\Model\YahooMailbox';
        $request = $this->connectYahooMailboxRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'connectYahooMailbox'
     *
     * @param  \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\ConnectOAuthMailboxRequest $request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function connectYahooMailboxRequest($request)
    {
        // verify the required parameter 'request' is set
        if ($request === null || (is_array($request) && count($request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request when calling connectYahooMailbox'
            );
        }

        $resourcePath = '/json/v2/mailboxes/connect/yahoo';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Authentication');
        if ($apiKey !== null) {
            $headers['X-Authentication'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation detectType
     *
     * Detect Mailbox Type
     *
     * @param  object $email email (required)
     *
     * @throws \AwardWallet\MainBundle\Service\EmailParsing\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\DetectTypeResponse
     */
    public function detectType($email)
    {
        list($response) = $this->detectTypeWithHttpInfo($email);
        return $response;
    }

    /**
     * Operation detectTypeWithHttpInfo
     *
     * Detect Mailbox Type
     *
     * @param  object $email (required)
     *
     * @throws \AwardWallet\MainBundle\Service\EmailParsing\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\DetectTypeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function detectTypeWithHttpInfo($email)
    {
        $returnType = '\AwardWallet\MainBundle\Service\EmailParsing\Client\Model\DetectTypeResponse';
        $request = $this->detectTypeRequest($email);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AwardWallet\MainBundle\Service\EmailParsing\Client\Model\DetectTypeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation detectTypeAsync
     *
     * Detect Mailbox Type
     *
     * @param  object $email (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function detectTypeAsync($email)
    {
        return $this->detectTypeAsyncWithHttpInfo($email)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation detectTypeAsyncWithHttpInfo
     *
     * Detect Mailbox Type
     *
     * @param  object $email (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function detectTypeAsyncWithHttpInfo($email)
    {
        $returnType = '\AwardWallet\MainBundle\Service\EmailParsing\Client\Model\DetectTypeResponse';
        $request = $this->detectTypeRequest($email);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'detectType'
     *
     * @param  object $email (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function detectTypeRequest($email)
    {
        // verify the required parameter 'email' is set
        if ($email === null || (is_array($email) && count($email) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $email when calling detectType'
            );
        }

        $resourcePath = '/json/v2/mailboxes/detect-type/{email}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($email !== null) {
            $resourcePath = str_replace(
                '{' . 'email' . '}',
                ObjectSerializer::toPathValue($email),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Authentication');
        if ($apiKey !== null) {
            $headers['X-Authentication'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation disconnectMailbox
     *
     * Disconnect Mailbox
     *
     * @param  int $mailboxId mailboxId (required)
     * @param  bool $revoke Revoke tokens for oauth mailboxes, default false (optional)
     *
     * @throws \AwardWallet\MainBundle\Service\EmailParsing\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function disconnectMailbox($mailboxId, $revoke = null)
    {
        $this->disconnectMailboxWithHttpInfo($mailboxId, $revoke);
    }

    /**
     * Operation disconnectMailboxWithHttpInfo
     *
     * Disconnect Mailbox
     *
     * @param  int $mailboxId (required)
     * @param  bool $revoke Revoke tokens for oauth mailboxes, default false (optional)
     *
     * @throws \AwardWallet\MainBundle\Service\EmailParsing\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function disconnectMailboxWithHttpInfo($mailboxId, $revoke = null)
    {
        $returnType = '';
        $request = $this->disconnectMailboxRequest($mailboxId, $revoke);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation disconnectMailboxAsync
     *
     * Disconnect Mailbox
     *
     * @param  int $mailboxId (required)
     * @param  bool $revoke Revoke tokens for oauth mailboxes, default false (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function disconnectMailboxAsync($mailboxId, $revoke = null)
    {
        return $this->disconnectMailboxAsyncWithHttpInfo($mailboxId, $revoke)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation disconnectMailboxAsyncWithHttpInfo
     *
     * Disconnect Mailbox
     *
     * @param  int $mailboxId (required)
     * @param  bool $revoke Revoke tokens for oauth mailboxes, default false (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function disconnectMailboxAsyncWithHttpInfo($mailboxId, $revoke = null)
    {
        $returnType = '';
        $request = $this->disconnectMailboxRequest($mailboxId, $revoke);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'disconnectMailbox'
     *
     * @param  int $mailboxId (required)
     * @param  bool $revoke Revoke tokens for oauth mailboxes, default false (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function disconnectMailboxRequest($mailboxId, $revoke = null)
    {
        // verify the required parameter 'mailboxId' is set
        if ($mailboxId === null || (is_array($mailboxId) && count($mailboxId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailboxId when calling disconnectMailbox'
            );
        }

        $resourcePath = '/json/v2/mailboxes/disconnect/{mailboxId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($revoke !== null) {
            $queryParams['revoke'] = ObjectSerializer::toQueryValue($revoke);
        }

        // path params
        if ($mailboxId !== null) {
            $resourcePath = str_replace(
                '{' . 'mailboxId' . '}',
                ObjectSerializer::toPathValue($mailboxId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Authentication');
        if ($apiKey !== null) {
            $headers['X-Authentication'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAuthCodeMailbox
     *
     * Begin Authentication
     *
     * @param  \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\StartAuthMailboxRequest $request request (required)
     *
     * @throws \AwardWallet\MainBundle\Service\EmailParsing\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getAuthCodeMailbox($request)
    {
        list($response) = $this->getAuthCodeMailboxWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation getAuthCodeMailboxWithHttpInfo
     *
     * Begin Authentication
     *
     * @param  \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\StartAuthMailboxRequest $request (required)
     *
     * @throws \AwardWallet\MainBundle\Service\EmailParsing\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAuthCodeMailboxWithHttpInfo($request)
    {
        $returnType = 'string';
        $request = $this->getAuthCodeMailboxRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAuthCodeMailboxAsync
     *
     * Begin Authentication
     *
     * @param  \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\StartAuthMailboxRequest $request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAuthCodeMailboxAsync($request)
    {
        return $this->getAuthCodeMailboxAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAuthCodeMailboxAsyncWithHttpInfo
     *
     * Begin Authentication
     *
     * @param  \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\StartAuthMailboxRequest $request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAuthCodeMailboxAsyncWithHttpInfo($request)
    {
        $returnType = 'string';
        $request = $this->getAuthCodeMailboxRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAuthCodeMailbox'
     *
     * @param  \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\StartAuthMailboxRequest $request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAuthCodeMailboxRequest($request)
    {
        // verify the required parameter 'request' is set
        if ($request === null || (is_array($request) && count($request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request when calling getAuthCodeMailbox'
            );
        }

        $resourcePath = '/json/v2/mailboxes/start-auth';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Authentication');
        if ($apiKey !== null) {
            $headers['X-Authentication'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMailbox
     *
     * Get Mailbox Info
     *
     * @param  int $mailboxId mailboxId (required)
     *
     * @throws \AwardWallet\MainBundle\Service\EmailParsing\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\Mailbox
     */
    public function getMailbox($mailboxId)
    {
        list($response) = $this->getMailboxWithHttpInfo($mailboxId);
        return $response;
    }

    /**
     * Operation getMailboxWithHttpInfo
     *
     * Get Mailbox Info
     *
     * @param  int $mailboxId (required)
     *
     * @throws \AwardWallet\MainBundle\Service\EmailParsing\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\Mailbox, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMailboxWithHttpInfo($mailboxId)
    {
        $returnType = '\AwardWallet\MainBundle\Service\EmailParsing\Client\Model\Mailbox';
        $request = $this->getMailboxRequest($mailboxId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AwardWallet\MainBundle\Service\EmailParsing\Client\Model\Mailbox',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMailboxAsync
     *
     * Get Mailbox Info
     *
     * @param  int $mailboxId (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMailboxAsync($mailboxId)
    {
        return $this->getMailboxAsyncWithHttpInfo($mailboxId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMailboxAsyncWithHttpInfo
     *
     * Get Mailbox Info
     *
     * @param  int $mailboxId (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMailboxAsyncWithHttpInfo($mailboxId)
    {
        $returnType = '\AwardWallet\MainBundle\Service\EmailParsing\Client\Model\Mailbox';
        $request = $this->getMailboxRequest($mailboxId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMailbox'
     *
     * @param  int $mailboxId (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getMailboxRequest($mailboxId)
    {
        // verify the required parameter 'mailboxId' is set
        if ($mailboxId === null || (is_array($mailboxId) && count($mailboxId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailboxId when calling getMailbox'
            );
        }

        $resourcePath = '/json/v2/mailboxes/{mailboxId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($mailboxId !== null) {
            $resourcePath = str_replace(
                '{' . 'mailboxId' . '}',
                ObjectSerializer::toPathValue($mailboxId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Authentication');
        if ($apiKey !== null) {
            $headers['X-Authentication'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listMailboxes
     *
     * List Mailboxes
     *
     * @param  object $tags tags (optional)
     * @param  object $states states (optional)
     * @param  object $types types (optional)
     * @param  object $errorCodes errorCodes (optional)
     *
     * @throws \AwardWallet\MainBundle\Service\EmailParsing\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object[]
     */
    public function listMailboxes($tags = null, $states = null, $types = null, $errorCodes = null)
    {
        list($response) = $this->listMailboxesWithHttpInfo($tags, $states, $types, $errorCodes);
        return $response;
    }

    /**
     * Operation listMailboxesWithHttpInfo
     *
     * List Mailboxes
     *
     * @param  object $tags (optional)
     * @param  object $states (optional)
     * @param  object $types (optional)
     * @param  object $errorCodes (optional)
     *
     * @throws \AwardWallet\MainBundle\Service\EmailParsing\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listMailboxesWithHttpInfo($tags = null, $states = null, $types = null, $errorCodes = null)
    {
        $returnType = 'object[]';
        $request = $this->listMailboxesRequest($tags, $states, $types, $errorCodes);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listMailboxesAsync
     *
     * List Mailboxes
     *
     * @param  object $tags (optional)
     * @param  object $states (optional)
     * @param  object $types (optional)
     * @param  object $errorCodes (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMailboxesAsync($tags = null, $states = null, $types = null, $errorCodes = null)
    {
        return $this->listMailboxesAsyncWithHttpInfo($tags, $states, $types, $errorCodes)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listMailboxesAsyncWithHttpInfo
     *
     * List Mailboxes
     *
     * @param  object $tags (optional)
     * @param  object $states (optional)
     * @param  object $types (optional)
     * @param  object $errorCodes (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMailboxesAsyncWithHttpInfo($tags = null, $states = null, $types = null, $errorCodes = null)
    {
        $returnType = 'object[]';
        $request = $this->listMailboxesRequest($tags, $states, $types, $errorCodes);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listMailboxes'
     *
     * @param  object $tags (optional)
     * @param  object $states (optional)
     * @param  object $types (optional)
     * @param  object $errorCodes (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listMailboxesRequest($tags = null, $states = null, $types = null, $errorCodes = null)
    {

        $resourcePath = '/json/v2/mailboxes/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($tags !== null) {
            $queryParams['tags'] = ObjectSerializer::toQueryValue($tags);
        }
        // query params
        if ($states !== null) {
            $queryParams['states'] = ObjectSerializer::toQueryValue($states);
        }
        // query params
        if ($types !== null) {
            $queryParams['types'] = ObjectSerializer::toQueryValue($types);
        }
        // query params
        if ($errorCodes !== null) {
            $queryParams['errorCodes'] = ObjectSerializer::toQueryValue($errorCodes);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Authentication');
        if ($apiKey !== null) {
            $headers['X-Authentication'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putMailbox
     *
     * Update Mailbox Info
     *
     * @param  int $mailboxId mailboxId (required)
     * @param  \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\UpdateMailboxRequest $request request (required)
     *
     * @throws \AwardWallet\MainBundle\Service\EmailParsing\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\Mailbox
     */
    public function putMailbox($mailboxId, $request)
    {
        list($response) = $this->putMailboxWithHttpInfo($mailboxId, $request);
        return $response;
    }

    /**
     * Operation putMailboxWithHttpInfo
     *
     * Update Mailbox Info
     *
     * @param  int $mailboxId (required)
     * @param  \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\UpdateMailboxRequest $request (required)
     *
     * @throws \AwardWallet\MainBundle\Service\EmailParsing\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\Mailbox, HTTP status code, HTTP response headers (array of strings)
     */
    public function putMailboxWithHttpInfo($mailboxId, $request)
    {
        $returnType = '\AwardWallet\MainBundle\Service\EmailParsing\Client\Model\Mailbox';
        $request = $this->putMailboxRequest($mailboxId, $request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AwardWallet\MainBundle\Service\EmailParsing\Client\Model\Mailbox',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putMailboxAsync
     *
     * Update Mailbox Info
     *
     * @param  int $mailboxId (required)
     * @param  \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\UpdateMailboxRequest $request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putMailboxAsync($mailboxId, $request)
    {
        return $this->putMailboxAsyncWithHttpInfo($mailboxId, $request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putMailboxAsyncWithHttpInfo
     *
     * Update Mailbox Info
     *
     * @param  int $mailboxId (required)
     * @param  \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\UpdateMailboxRequest $request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putMailboxAsyncWithHttpInfo($mailboxId, $request)
    {
        $returnType = '\AwardWallet\MainBundle\Service\EmailParsing\Client\Model\Mailbox';
        $request = $this->putMailboxRequest($mailboxId, $request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putMailbox'
     *
     * @param  int $mailboxId (required)
     * @param  \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\UpdateMailboxRequest $request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putMailboxRequest($mailboxId, $request)
    {
        // verify the required parameter 'mailboxId' is set
        if ($mailboxId === null || (is_array($mailboxId) && count($mailboxId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mailboxId when calling putMailbox'
            );
        }
        // verify the required parameter 'request' is set
        if ($request === null || (is_array($request) && count($request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request when calling putMailbox'
            );
        }

        $resourcePath = '/json/v2/mailboxes/{mailboxId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($mailboxId !== null) {
            $resourcePath = str_replace(
                '{' . 'mailboxId' . '}',
                ObjectSerializer::toPathValue($mailboxId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Authentication');
        if ($apiKey !== null) {
            $headers['X-Authentication'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation scrollMailboxes
     *
     * List Mailboxes with paging support
     *
     * @param  object $tags tags (optional)
     * @param  object $states states (optional)
     * @param  object $types types (optional)
     * @param  object $errorCodes errorCodes (optional)
     * @param  object $pageToken pageToken (optional)
     *
     * @throws \AwardWallet\MainBundle\Service\EmailParsing\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\ScrollMailboxesResponse
     */
    public function scrollMailboxes($tags = null, $states = null, $types = null, $errorCodes = null, $pageToken = null)
    {
        list($response) = $this->scrollMailboxesWithHttpInfo($tags, $states, $types, $errorCodes, $pageToken);
        return $response;
    }

    /**
     * Operation scrollMailboxesWithHttpInfo
     *
     * List Mailboxes with paging support
     *
     * @param  object $tags (optional)
     * @param  object $states (optional)
     * @param  object $types (optional)
     * @param  object $errorCodes (optional)
     * @param  object $pageToken (optional)
     *
     * @throws \AwardWallet\MainBundle\Service\EmailParsing\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \AwardWallet\MainBundle\Service\EmailParsing\Client\Model\ScrollMailboxesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function scrollMailboxesWithHttpInfo($tags = null, $states = null, $types = null, $errorCodes = null, $pageToken = null)
    {
        $returnType = '\AwardWallet\MainBundle\Service\EmailParsing\Client\Model\ScrollMailboxesResponse';
        $request = $this->scrollMailboxesRequest($tags, $states, $types, $errorCodes, $pageToken);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AwardWallet\MainBundle\Service\EmailParsing\Client\Model\ScrollMailboxesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation scrollMailboxesAsync
     *
     * List Mailboxes with paging support
     *
     * @param  object $tags (optional)
     * @param  object $states (optional)
     * @param  object $types (optional)
     * @param  object $errorCodes (optional)
     * @param  object $pageToken (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scrollMailboxesAsync($tags = null, $states = null, $types = null, $errorCodes = null, $pageToken = null)
    {
        return $this->scrollMailboxesAsyncWithHttpInfo($tags, $states, $types, $errorCodes, $pageToken)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation scrollMailboxesAsyncWithHttpInfo
     *
     * List Mailboxes with paging support
     *
     * @param  object $tags (optional)
     * @param  object $states (optional)
     * @param  object $types (optional)
     * @param  object $errorCodes (optional)
     * @param  object $pageToken (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scrollMailboxesAsyncWithHttpInfo($tags = null, $states = null, $types = null, $errorCodes = null, $pageToken = null)
    {
        $returnType = '\AwardWallet\MainBundle\Service\EmailParsing\Client\Model\ScrollMailboxesResponse';
        $request = $this->scrollMailboxesRequest($tags, $states, $types, $errorCodes, $pageToken);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'scrollMailboxes'
     *
     * @param  object $tags (optional)
     * @param  object $states (optional)
     * @param  object $types (optional)
     * @param  object $errorCodes (optional)
     * @param  object $pageToken (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function scrollMailboxesRequest($tags = null, $states = null, $types = null, $errorCodes = null, $pageToken = null)
    {

        $resourcePath = '/json/v2/mailboxes/scroll';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($tags !== null) {
            $queryParams['tags'] = ObjectSerializer::toQueryValue($tags);
        }
        // query params
        if ($states !== null) {
            $queryParams['states'] = ObjectSerializer::toQueryValue($states);
        }
        // query params
        if ($types !== null) {
            $queryParams['types'] = ObjectSerializer::toQueryValue($types);
        }
        // query params
        if ($errorCodes !== null) {
            $queryParams['errorCodes'] = ObjectSerializer::toQueryValue($errorCodes);
        }
        // query params
        if ($pageToken !== null) {
            $queryParams['pageToken'] = ObjectSerializer::toQueryValue($pageToken);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Authentication');
        if ($apiKey !== null) {
            $headers['X-Authentication'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
