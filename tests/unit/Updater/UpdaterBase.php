<?php

namespace AwardWallet\Tests\Unit\Updater;

use AwardWallet\MainBundle\Event\AccountUpdatedEvent;
use AwardWallet\MainBundle\Globals\Utils\LazyVal;
use AwardWallet\MainBundle\Updater\Event\AbstractEvent;
use AwardWallet\MainBundle\Updater\Event\DebugEvent;
use AwardWallet\MainBundle\Updater\Event\DisabledEvent;
use AwardWallet\MainBundle\Updater\Event\ErrorEvent;
use AwardWallet\MainBundle\Updater\Event\ExtensionEvent;
use AwardWallet\MainBundle\Updater\Event\StartProgressEvent;
use AwardWallet\MainBundle\Updater\Event\TripsFoundEvent;
use AwardWallet\MainBundle\Updater\Event\TripsNotFoundEvent;
use AwardWallet\MainBundle\Updater\Event\UpdatedEvent;
use AwardWallet\MainBundle\Updater\StartResponse;
use AwardWallet\MainBundle\Updater\UpdaterSession;
use AwardWallet\Tests\Unit\BaseUserTest;

use function AwardWallet\MainBundle\Globals\Utils\iterFluent\it;

class UpdaterBase extends BaseUserTest
{
    protected $UPDATER_SERVICE;

    /**
     * @var UpdaterSession
     */
    private $updater;

    public function _before()
    {
        parent::_before();

        $this->UPDATER_SERVICE = 'aw.updater_session.desktop';
    }

    public function _after()
    {
        $this->updater = null;

        parent::_after(); // TODO: Change the autogenerated stub
    }

    protected function getUpdater(): UpdaterSession
    {
        if ($this->updater === null) {
            $this->updater = $this->container->get($this->UPDATER_SERVICE);
        }

        return $this->updater;
    }

    /**
     * @param list<AbstractEvent> $updaterEvents
     * @param array<class-string<AbstractEvent>, callable(AbstractEvent): AbstractEvent> $formattersMap
     * @return list<AbstractEvent>
     */
    protected function formatEvents(array $updaterEvents, array $formattersMap): array
    {
        foreach ($updaterEvents as $idx => $event) {
            $class = \get_class($event);

            do {
                $classFormatter = $formattersMap[$class] ?? null;

                if ($classFormatter) {
                    $updaterEvents[$idx] = $classFormatter($event);

                    break;
                }
            } while (false !== ($class = \get_parent_class($class)));
        }

        return $updaterEvents;
    }

    /**
     * @param list<AbstractEvent> $expected
     * @param array<class-string<AbstractEvent>, callable(AbstractEvent): AbstractEvent> $eventFormatters
     */
    protected function waitEvents(StartResponse $result, array $expected, bool $skipDebug = true, array $eventFormatters = []): void
    {
        $actual = \array_values($this->getEvents($result, $expected, $skipDebug));
        $actual = $skipDebug ? self::filterDebug($actual) : $actual;

        if ($eventFormatters) {
            $actual = $this->formatEvents($actual, $eventFormatters);
        }

        $this->assertEquals($expected, $actual);
    }

    /**
     * @return list<AbstractEvent>
     */
    protected function getEventsWithoutDebug(StartResponse $result, array $expected): array
    {
        return self::filterDebug($this->getEvents($result, $expected));
    }

    /**
     * @return list<AbstractEvent>
     */
    protected function getEvents(StartResponse $result, array $expected, bool $skipDebug = true): array
    {
        $n = 0;
        $cache = \Cache::getInstance();

        $filter = fn (array $events) => $skipDebug ?
            self::filterDebug($events) :
            $events;

        $emptyTicks = 0;

        while (count($filter($result->events)) < count($expected) && $emptyTicks < 3) {
            $newEvents = $this->updater->tick($result->key, count($result->events));
            $result->events = array_merge($result->events, $newEvents);

            $newEvents = self::filterDebug($newEvents);

            if (count($newEvents) > 0) {
                $emptyTicks = 0;
            } else {
                $emptyTicks++;
            }

            if ($n > 0 && count($result->events) < count($expected)) {
                $cache->waitForKey("account_saved_" . gethostname(), 3);
            }
            $n++;
        }

        foreach ($result->events as &$event) {
            if ($event instanceof ErrorEvent || $event instanceof TripsFoundEvent || $event instanceof DisabledEvent) {
                $event->accountData = null;
            }

            if ($event instanceof StartProgressEvent || $event instanceof ExtensionEvent) {
                $event->expectedDuration = 30;

                if ($event instanceof StartProgressEvent) {
                    $event->checkIts = null;
                }
            }

            if ($event instanceof TripsFoundEvent) {
                $event->tripIds = [];
            }

            if ($event instanceof TripsNotFoundEvent
                || $event instanceof UpdatedEvent
            ) {
                $event->accountData = null;
            }
        }
        unset($event);

        return $result->events;
    }

    /**
     * @param AbstractEvent[] $events
     * @return AbstractEvent[]
     */
    protected static function filterDebug(array $events): array
    {
        return it($events)
            ->filterNot(fn (AbstractEvent $event) => $event instanceof DebugEvent)
            ->toArray();
    }

    protected function updateAccount($accountId, $extraEvents = [])
    {
        $cache = \Cache::getInstance();
        $cache->delete("account_saved_" . gethostname());
        $result = $this->getUpdater()->start([$accountId]);

        if (empty($extraEvents)) {
            $extraEvents = [new UpdatedEvent($accountId, null)];
        }
        $expected = array_merge([
            new StartProgressEvent($accountId, 30, null),
        ], $extraEvents);
        $this->waitEvents($result, $expected);
    }

    /**
     * @return LazyVal<string>
     */
    protected function catchLoyaltyRequestId(int $accountId): LazyVal
    {
        $loyaltyRequestId = null;
        $this->container->get('event_dispatcher')->addListener('aw.account_updated', function (AccountUpdatedEvent $event) use (&$loyaltyRequestId, $accountId) {
            if ($event->getAccount()->getId() === $accountId) {
                $loyaltyRequestId = $event->getCheckAccountResponse()->getRequestid();
            }
        });

        return new LazyVal(function () use (&$loyaltyRequestId) {
            if ($loyaltyRequestId === null) {
                throw new \LogicException('Loyalty request id is null. You called value too soon');
            }

            return $loyaltyRequestId;
        });
    }
}
