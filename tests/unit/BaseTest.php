<?php

namespace AwardWallet\Tests\Unit;

use AwardWallet\Tests\Modules\AwAssert;
use AwardWallet\Tests\Modules\Utils\Prophecy\ObjectProphecyExtended;
use AwardWallet\Tests\Modules\Utils\Prophecy\ProphetExtended;
use Codeception\Module\Aw;
use Codeception\Module\CustomDb;
use Codeception\Module\DbBuilder;
use Codeception\TestCase\Test;
use PHPUnit\Framework\MockObject\MockObject;
use Prophecy\PhpUnit\ProphecyTrait;
use Prophecy\Prophecy\MethodProphecy;

abstract class BaseTest extends Test
{
    use ProphecyTrait;
    /**
     * @var Aw
     */
    protected $aw;
    /**
     * @var CustomDb
     */
    protected $db;

    /**
     * @var DbBuilder
     */
    protected $dbBuilder;

    protected $backupGlobalsBlacklist = ['Connection', 'symfonyContainer'];

    /**
     * @var ProphetExtended
     */
    protected $prophetExtended;

    protected function assertPostConditions(): void
    {
        if ($this->prophetExtended !== null) {
            try {
                $this->prophetExtended->checkPredictions();
            } finally {
                foreach ($this->prophetExtended->getProphecies() as $objectProphecy) {
                    foreach ($objectProphecy->getMethodProphecies() as $methodProphecies) {
                        foreach ($methodProphecies as $methodProphecy) {
                            assert($methodProphecy instanceof MethodProphecy);

                            $this->addToAssertionCount(count($methodProphecy->getCheckedPredictions()));
                        }
                    }
                }
            }
        }
    }

    public function _before()
    {
        $this->backupGlobalsBlacklist[] = '';
        parent::_before(); // TODO: Change the autogenerated stub

        $this->aw = $this->getModule('Aw');
        $this->db = $this->getModule('CustomDb');
        $this->dbBuilder = $this->getModule('DbBuilder');
    }

    public function assertArrayContainsArray(array $expected, array $actual)
    {
        AwAssert::assertArrayContainsArray($expected, $actual);
    }

    /**
     * creates deferred assertion that no method will be invoked on mock-object.
     *
     * @return \PHPUnit_Framework_MockObject_MockObject
     */
    protected function neverUsed(MockObject $object)
    {
        $object->expects($this->never())->method($this->anything());

        return $object;
    }

    /**
     * @param array|callable $subset array or callback returning array
     * @return \PHPUnit_Framework_Constraint_Callback
     */
    protected function arrayArgumentWithSubset($subset)
    {
        return $this->callback(function (array $context) use ($subset) {
            $this->assertTrue(is_array($context), 'argument is not an array');
            $this->assertArrayContainsArray(is_callable($subset) ? $subset() : $subset, $context);

            return true;
        });
    }

    protected function prophesizeExtended($classOrInterface = null): ObjectProphecyExtended
    {
        return $this->getProphetExtended()->prophesize($classOrInterface);
    }

    protected function getProphetExtended(): ProphetExtended
    {
        if (!$this->prophetExtended) {
            $this->prophetExtended = new ProphetExtended();
        }

        return $this->prophetExtended;
    }

    /**
     * @param string|object $classOrObject
     * @return ObjectProphecyExtended[]
     */
    protected function prophesizeConstructorArguments($classOrObject, array $argsMixinMap = []): array
    {
        return $this->getProphetExtended()->prophesizeConstructorArguments($classOrObject, $argsMixinMap);
    }

    /**
     * @param string|object $classOrObject
     * @return ObjectProphecyExtended[]
     */
    protected function prophesizeConstructorArgumentsMuted($classOrObject, array $argsMixinMap = []): array
    {
        return $this->getProphetExtended()->prophesizeConstructorArgumentsMuted($classOrObject, $argsMixinMap);
    }

    /**
     * @return $classOrObject
     */
    protected function makeProphesized($classOrObject, array $argsMixinMap = []): object
    {
        return new $classOrObject(
            ...$this->prophesizeConstructorArguments($classOrObject, $argsMixinMap)
        );
    }

    /**
     * @return $classOrObject
     */
    protected function makeProphesizedMuted($classOrObject, array $argsMixinMap = []): object
    {
        return new $classOrObject(
            ...$this->prophesizeConstructorArgumentsMuted($classOrObject, $argsMixinMap)
        );
    }

    /**
     * @param numeric|\DateTimeInterface $date
     */
    protected function convertToSql($date)
    {
        if (is_numeric($date)) {
            $timestamp = (int) $date;
        } elseif ($date instanceof \DateTimeInterface) {
            $timestamp = $date->getTimestamp();
        } else {
            throw new \InvalidArgumentException(sprintf('Unexpeced date type "%s", should be numeric or \DateTimeInterface', gettype($date)));
        }

        return date('Y-m-d H:i:s', $timestamp);
    }

    protected function constructWithPartial(string $class, array $partialConstructorArgsMap): object
    {
        $reflClass = new \ReflectionClass($class);
        $consRefl = $reflClass->getConstructor();
        $argumentsList = [];
        $usedArgumentsNamesList = [];

        foreach ($consRefl->getParameters() as $parameterRefl) {
            $name = $parameterRefl->getName();

            if (\array_key_exists($name, $partialConstructorArgsMap)) {
                $usedArgumentsNamesList[] = $name;
                $argumentsList[] = $partialConstructorArgsMap[$name];
            } elseif ($paramClass = $parameterRefl->getClass()) {
                $usedArgumentsNamesList[] = $name;
                $argumentsList[] = $this->prophesize($paramClass->getName())->reveal();
            } else {
                throw new \InvalidArgumentException('No value provided for $' . $name);
            }
        }

        $diff = \array_diff(
            \array_keys($partialConstructorArgsMap),
            $usedArgumentsNamesList
        );

        if ($diff) {
            throw new \InvalidArgumentException('Unknown arguments: ' . \json_encode(\array_values($diff)));
        }

        return new $class(...$argumentsList);
    }
}
