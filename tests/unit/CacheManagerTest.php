<?php

namespace AwardWallet\Tests\Unit;

use AwardWallet\MainBundle\FrameworkExtension\Error\SimpleLeveledErrorReporter;
use AwardWallet\MainBundle\Globals\StringHandler;
use AwardWallet\MainBundle\Service\Cache\CacheManager;
use AwardWallet\MainBundle\Service\Cache\Model\CacheItem;
use AwardWallet\MainBundle\Service\Cache\Model\CacheItemReference;
use AwardWallet\MainBundle\Service\Cache\StampedeProtector;
use AwardWallet\MainBundle\Service\Cache\Tags;
use AwardWallet\MainBundle\Service\MileValue\MileValueCache;
use Clock\ClockNative;
use PHPUnit\Framework\AssertionFailedError;
use Prophecy\Argument;
use Psr\Log\LoggerInterface;
use Symfony\Component\Lock\Key;
use Symfony\Component\Lock\Lock;
use Symfony\Component\Lock\Store\MemcachedStore;

use function Duration\seconds;
use function PHPUnit\Framework\assertEquals;

/**
 * @group frontend-unit
 */
class CacheManagerTest extends BaseContainerTest
{
    /**
     * @var CacheManager
     */
    private $cacheManager;

    /**
     * @var \Memcached
     */
    private $memcached;
    private $mileValueCache;

    public function _before()
    {
        parent::_before();

        $this->cacheManager = $this->container->get(CacheManager::class);
        $this->memcached = $this->container->get(\Memcached::class);
        $this->mileValueCache = $this->container->get(MileValueCache::class);
    }

    public function _after()
    {
        $this->memcached =
        $this->cacheManager = null;

        parent::_after(); // TODO: Change the autogenerated stub
    }

    public function testSimple()
    {
        $data = StringHandler::getRandomCode(10);
        $this->memcached->set($key = "test_simple" . $data, $item = ['data' => serialize($data)]);
        $this->cacheManager->load(new CacheItemReference($key, [], null));
        $this->assertEquals($item, $this->memcached->get($key));
    }

    public function testForceUpdate()
    {
        $cacheCalculateCounter = 0;
        $cacheItemReference = (new CacheItemReference(
            $key = 'testKey' . StringHandler::getRandomCode(10),
            [],
            function () use (&$cacheCalculateCounter) {
                return $cacheCalculateCounter++;
            },
        ));

        $expected = 1;

        for ($i = $cacheCalculateCounter; $i < 3; $i++) {
            $this->cacheManager->load($cacheItemReference);
            $this->assertEquals($expected, $cacheCalculateCounter);
        }

        $cacheItemReference->setForce(true);

        foreach ([2, 3, 4] as $expected) {
            $this->cacheManager->load($cacheItemReference);
            $this->assertEquals($expected, $cacheCalculateCounter);
        }

        $cacheItemReference->setForce(false);

        foreach ([4, 4, 4] as $expected) {
            $this->cacheManager->load($cacheItemReference);
            $this->assertEquals($expected, $cacheCalculateCounter);
        }
    }

    /**
     * @dataProvider useTagsForExpirationDataProvider
     */
    public function testExpiration(array $tags)
    {
        $data = StringHandler::getRandomCode(10);
        $this->cacheManager->load((new CacheItemReference($key = "test_exp" . $data, $tags, $data))->setExpiration(1));
        $this->assertEquals($data, $this->cacheManager->load(new CacheItemReference($key, $tags, null)));
        usleep(1.2e6);
        $this->assertEquals($data . 'new', $this->cacheManager->load(new CacheItemReference($key, $tags, $data . 'new')));
    }

    public function useTagsForExpirationDataProvider()
    {
        return [
            'with tags' => [Tags::addTagPrefix([
                StringHandler::getRandomCode(10),
                StringHandler::getRandomCode(10),
                StringHandler::getRandomCode(10),
            ])],
            'without tags' => [[]],
        ];
    }

    /**
     * @dataProvider useTagsForExpirationDataProvider
     */
    public function testSuccessStampedeMitigationExpiration(array $tags)
    {
        $data = StringHandler::getRandomCode(10);
        $this->cacheManager->load(new CacheItemReference($key = "test_exp" . $data, $tags, $data));

        foreach (range(0, 100) as $i) {
            $loadedData = $this->cacheManager->load(
                (new CacheItemReference($key, $tags, $data . 'new'))
                ->setExpiration(100)
                ->setStampedeMitigationBeta(100)
            );

            if ($loadedData === ($data . 'new')) {
                return;
            }
        }

        $this->fail('stampede mitigation failed should be triggered');
    }

    /**
     * @dataProvider useTagsForExpirationDataProvider
     */
    public function testFailedStampedeMitigationExpiration(array $tags)
    {
        $data = StringHandler::getRandomCode(10);
        $this->cacheManager->load(new CacheItemReference($key = "test_exp" . $data, $tags, $data));

        foreach (range(0, 100) as $i) {
            $loadedData = $this->cacheManager->load(
                (new CacheItemReference($key, $tags, $data . 'new'))
                ->setExpiration(100)
                ->setStampedeMitigationBeta(1)
            );

            if ($loadedData === ($data . 'new')) {
                $this->fail('stampede mitigation should not be triggered');
            }
        }
    }

    public function testFailedStampedeMitigationExpirationWithExistingItem()
    {
        $tags = $this->useTagsForExpirationDataProvider()['with tags'][0];
        $data = StringHandler::getRandomCode(10);
        $this->memcached->set(
            $key = "test_exp" . $data,
            [
                'data' => $data,
                'tags' => $tags,
                'flags' => [],
                'ctime' => \time() - 1000,
            ],
            CacheManager::ITEM_EXPIRATION,
        );
        $this->cacheManager->load(new CacheItemReference(
            $key = "test_exp" . $data,
            // trigger invalidation by altering tags set
            \array_merge($tags, Tags::addTagPrefix(['some_other' . $data])),
            $data
        ));

        foreach (range(0, 100) as $i) {
            $loadedData = $this->cacheManager->load(
                (new CacheItemReference($key, \array_merge($tags, Tags::addTagPrefix(['some_other' . $data])), $data . 'new'))
                ->setExpiration(100)
                ->setStampedeMitigationBeta(1)
            );

            if ($loadedData === ($data . 'new')) {
                $this->fail('stampede mitigation should not be triggered');
            }
        }
    }

    public function testTags()
    {
        $data = StringHandler::getRandomCode(10);
        $this->cacheManager->load(new CacheItemReference($key = "test_tags" . $data, $tags = Tags::addTagPrefix(['a', 'b']), $data));
        $this->assertEquals($data, $this->cacheManager->load(new CacheItemReference($key, $tags, $data)));

        $this->cacheManager->invalidateTags(["a"]);
        $this->assertEquals($data . 'new', $this->cacheManager->load(new CacheItemReference($key, $tags, $data . 'new')));
    }

    public function testMemcachedPerformance()
    {
        $startTime = microtime(true);

        for ($n = 0; $n < 100; $n++) {
            $this->memcached->get(StringHandler::getRandomCode(10));
        }
        $duration = microtime(true) - $startTime;
        $this->assertLessThan(0.1, $duration);
    }

    public function testValidate()
    {
        $itemKey = 'testValidateMissing_' . StringHandler::getRandomCode(10);
        $itemTags = [
            'tag_0_testValidateMissing_' . StringHandler::getRandomCode(10) => 1,
            'tag_1_testValidateMissing_' . StringHandler::getRandomCode(10) => 2,
        ];

        foreach ($itemTags as $key => $value) {
            $this->memcached->set($key, $value, 3600);
        }

        $referenceTags = array_slice($itemTags, 1);
        $referenceTags[$tagKey = 'tag_2_testValidateMissing_' . StringHandler::getRandomCode(10)] = 0;

        $reference = new CacheItemReference($itemKey, array_keys($referenceTags), null);

        $this->cacheManager->load($reference);

        $this->assertEquals(1, $this->memcached->get(array_keys($itemTags)[0]));
        $this->assertEquals(2, $this->memcached->get(array_keys($referenceTags)[0]));
        $this->assertEquals(0, (int) $this->memcached->get(array_keys($referenceTags)[1]));

        $this->cacheManager->load($reference);

        $this->assertEquals(2, $this->memcached->get(array_keys($referenceTags)[0]));
        $this->assertEquals(0, (int) $this->memcached->get(array_keys($referenceTags)[1]));
    }

    public function testLoadWithCtime()
    {
        [$key, $tags] = $this->getDefaultCacheItems('LoadWithStore');

        $data = new \stdClass();
        $loaded = $this->cacheManager->load(
            (new CacheItemReference($key, $tags, $data))
            ->setSerializer(
                function ($_data) use ($data) {
                    $this->assertTrue($data === $_data, 'Not the same object');

                    return $_data;
                }
            )->setDeserializer($this->shouldNotBeCalledCallback())
        );

        $this->assertTrue($loaded === $data);

        $this->assertArrayContainsArray(
            [
                'data' => 'O:8:"stdClass":0:{}',
                'tags' => array_combine($tags, [0, 0]),
                'flags' => 0,
            ],
            $stored = $this->memcached->get($key)
        );

        $this->assertEqualsWithDelta($stored['ctime'], \microtime(true), 5, '');
    }

    public function testLoadStored()
    {
        [$key, $tags] = $this->getDefaultCacheItems('LoadWithStore');
        $this->memcached->set($key,
            [
                'data' => 'O:8:"stdClass":0:{}',
                'tags' => array_combine($tags, [0, 0]),
            ]
        );

        $data = new \stdClass();
        $loaded = $this->cacheManager->load(
            (new CacheItemReference($key, $tags, $data))
            ->setSerializer($this->shouldNotBeCalledCallback())
            ->setDeserializer(
                function (\stdClass $_data) use ($data) {
                    $this->assertFalse($data === $_data);

                    $_data->property1 = 100;

                    return $_data;
                }
            )
        );

        $this->assertEquals(100, $loaded->property1);
    }

    public function testLoadUnknownClass()
    {
        [$key, $tags] = $this->getDefaultCacheItems('LoadWithStore');
        $this->assertFalse(class_exists('stlrdCilass', true));
        $this->memcached->set($key, ['data' => 'O:11:"stlrdCilass":0:{}', 'tags' => array_combine($tags, [0, 0])]);

        $data = new \stdClass();
        $errorReporter = $this->prophesize(SimpleLeveledErrorReporter::class);
        $errorReporter
            ->logThrowable(Argument::type(\Throwable::class), Argument::cetera())
            ->shouldBeCalled();
        $cacheManager = new CacheManager(
            $this->memcached,
            $this->container->get(LoggerInterface::class),
            $errorReporter->reveal(),
            new StampedeProtector(),
            false
        );
        $loaded = $cacheManager->load(new CacheItemReference($key, $tags, $data));
        $this->assertTrue($data === $loaded);
        $this->assertCacheResNotFound([$key]);
    }

    public function testSerializationFail()
    {
        [$key, $tags] = $this->getDefaultCacheItems('SerializationFail');
        $errorReporter = $this->prophesize(SimpleLeveledErrorReporter::class);
        $errorReporter
            ->logThrowable(Argument::type(\Throwable::class), Argument::cetera())
            ->shouldBeCalled();
        $cacheManager = new CacheManager(
            $this->memcached,
            $this->container->get(LoggerInterface::class),
            $errorReporter->reveal(),
            new StampedeProtector(),
            false,
        );
        // Internal data fail

        /** @var FailOnSerialization $loaded */
        $loaded = $cacheManager->load(
            (new CacheItemReference(
                $key,
                $tags,
                function () {
                    static $counter = 0;

                    $object = new FailOnSerialization();
                    $object->payload = ++$counter;

                    return $object;
                }
            ))
            ->setSerializer($this->shouldNotBeCalledCallback())
            ->setDeserializer($this->shouldNotBeCalledCallback())
        );

        $this->assertEquals(1, $loaded->payload);

        // Serializer callback fail

        /** @var FailOnSerialization $loaded */
        $loaded = $cacheManager->load(
            (new CacheItemReference(
                $key,
                $tags,
                function () {
                    static $counter = 0;

                    $object = new FailOnSerialization();
                    $object->payload = ++$counter;

                    return $object;
                }
            ))->setSerializer(function () { throw new \Exception('buggy serializer'); })
            ->setDeserializer($this->shouldNotBeCalledCallback())
        );

        $this->assertEquals(1, $loaded->payload);
    }

    public function testCASFailWithoutRetries()
    {
        [$key, $tags] = $this->getDefaultCacheItems('CASFail');
        $this->memcached->set($key, ['data' => 'O:8:"stdClass":0:{}', 'tags' => array_combine($tags, [0, 1])]); // invalid tags

        $dataProviderCallsCount = 0;
        $cacheManager = new CacheManager(
            $this->memcached,
            $logger = $this->container->get(LoggerInterface::class),
            new SimpleLeveledErrorReporter($logger),
            new StampedeProtector(),
            false,
        );

        $data = $cacheManager->load(
            (new CacheItemReference($key, $tags,
                function () use (&$dataProviderCallsCount) {
                    $dataProviderCallsCount++;

                    $data = new \stdClass();
                    $data->prop = 'val';

                    return $data;
                }
            ))->setSerializer(function ($data) {
                // "disconnect" from memcached, trigger error right before cas-store
                $this->memcached->resetServerList();

                return $data;
            })
        );

        $this->assertEquals(1, $dataProviderCallsCount);
        $this->assertEquals('O:8:"stdClass":1:{s:4:"prop";s:3:"val";}', serialize($data));
    }

    public function testCASFailWithRetries()
    {
        [$key, $tags] = $this->getDefaultCacheItems('CASFail');
        $this->memcached->set($key, ['data' => 'O:8:"stdClass":0:{}', 'tags' => array_combine($tags, [0, 1])]); // invalid tags

        // Test one attempt

        $dataProviderCallsCount = 0;
        $data = $this->cacheManager->load(
            (new CacheItemReference($key, $tags,
                function () use (&$dataProviderCallsCount) {
                    $dataProviderCallsCount++;

                    $data = new \stdClass();
                    $data->prop = 'val';

                    return $data;
                }
            ))->setSerializer(function ($data) use ($key, &$dataProviderCallsCount) {
                // trigger error only for the first time right before cas-store
                if ($dataProviderCallsCount === 1) {
                    $this->memcached->set($key, -1);
                }

                return $data;
            })
        );

        assertEquals(1, $dataProviderCallsCount);
        assertEquals($expectedData = 'O:8:"stdClass":1:{s:4:"prop";s:3:"val";}', serialize($data));
        assertEquals(-1, $this->memcached->get($key));

        $this->memcached->set($key, ['data' => 'O:8:"stdClass":0:{}', 'tags' => array_combine($tags, [0, 1])]); // invalid tags

        // Test many attempts

        $dataProviderCallsCount = 0;
        $data = $this->cacheManager->load(
            (new CacheItemReference($key, $tags,
                function () use (&$dataProviderCallsCount) {
                    $dataProviderCallsCount++;

                    $data = new \stdClass();
                    $data->prop = 'val';

                    return $data;
                }
            ))->setSerializer(function ($data) use ($key, &$dataProviderCallsCount) {
                // trigger error every time right before cas-store
                $this->memcached->set($key, $dataProviderCallsCount . 'data');

                return $data;
            })
        );

        assertEquals(1, $dataProviderCallsCount);
        assertEquals(1 . 'data', $this->memcached->get($key));
        assertEquals('O:8:"stdClass":1:{s:4:"prop";s:3:"val";}', serialize($data));
    }

    public function testUnserializationFail()
    {
        [$key, $tags] = $this->getDefaultCacheItems('SerializationFail');
        $this->memcached->set($key, ['data' => 'O:44:"AwardWallet\Tests\Unit\FailOnDeserialization":1:{s:7:"payload";i:0;}', 'tags' => array_combine($tags, [0, 0])]);
        $errorReporter = $this->prophesize(SimpleLeveledErrorReporter::class);
        $errorReporter
            ->logThrowable(Argument::type(\Throwable::class), Argument::cetera())
            ->shouldBeCalled();
        $cacheManager = new CacheManager(
            $this->memcached,
            $this->container->get(LoggerInterface::class),
            $errorReporter->reveal(),
            new StampedeProtector(),
            false,
        );
        // Internal data fail

        /** @var FailOnSerialization $loaded */
        $loaded = $cacheManager->load(
            new CacheItemReference(
                $key,
                $tags,
                function () {
                    static $counter = 0;

                    $object = new FailOnSerialization();
                    $object->payload = ++$counter;

                    return $object;
                },
                $this->shouldNotBeCalledCallback(),
                $this->shouldNotBeCalledCallback()
            )
        );

        $this->assertEquals(1, $loaded->payload);
        $this->assertCacheResNotFound($key);

        // Unserializer callback fail

        $this->memcached->set($key, ['data' => 'O:8:"stdClass":0:{}', 'tags' => array_combine($tags, [0, 0])]);

        $errorReporter = $this->prophesize(SimpleLeveledErrorReporter::class);
        $errorReporter
            ->logThrowable(Argument::type(\Throwable::class), Argument::cetera())
            ->shouldBeCalled();
        $cacheManager = new CacheManager(
            $this->memcached,
            $this->container->get(LoggerInterface::class),
            $errorReporter->reveal(),
            new StampedeProtector(),
            false,
        );

        /** @var FailOnSerialization $loaded */
        $loaded = $cacheManager->load(
            new CacheItemReference(
                $key,
                $tags,
                function () {
                    static $counter = 0;

                    $object = new FailOnSerialization();
                    $object->payload = ++$counter;

                    return $object;
                },
                $this->shouldNotBeCalledCallback(),
                function () {
                    throw new \Exception('buggy unserializer');
                }
            )
        );

        $this->assertEquals(1, $loaded->payload);
        $this->assertCacheResNotFound($key);

        // Test malformed serialized format

        $this->memcached->set($key, ['data' => 'O:100500:"stdClass":0:{}', 'tags' => array_combine($tags, [0, 0])]);

        $errorReporter = $this->prophesize(SimpleLeveledErrorReporter::class);
        $errorReporter
            ->logThrowable(Argument::type(\Throwable::class), Argument::cetera())
            ->shouldBeCalled();
        $cacheManager = new CacheManager(
            $this->memcached,
            $this->container->get(LoggerInterface::class),
            $errorReporter->reveal(),
            new StampedeProtector(),
            false,
        );

        /** @var FailOnSerialization $loaded */
        $loaded = $cacheManager->load(
            new CacheItemReference(
                $key,
                $tags,
                function () {
                    static $counter = 0;

                    $object = new FailOnSerialization();
                    $object->payload = ++$counter;

                    return $object;
                },
                $this->shouldNotBeCalledCallback(),
                function () {
                    throw new \Exception('buggy unserializer');
                }
            )
        );
        $this->assertEquals(1, $loaded->payload);
        $this->assertCacheResNotFound($key);
    }

    public function testFailedMemcached()
    {
        $logger = $this->createMock(LoggerInterface::class);

        @$memcached = $this->getMockBuilder(\Memcached::class)->disableOriginalConstructor()->getMock();
        $memcached->expects($this->once())->method('getMulti')
            ->willReturn(null);
        $memcached->expects($this->once())->method('getResultCode')
            ->willReturn(\Memcached::RES_HOST_LOOKUP_FAILURE);
        $memcached->expects($this->once())->method('getResultMessage')
            ->willReturn('ALL FUCKED UP!');

        $cacheManager = new CacheManager(
            $memcached,
            $logger,
            new SimpleLeveledErrorReporter($logger),
            new StampedeProtector(),
            false,
        );
        $data = $cacheManager->load(new CacheItemReference('some_key', ['some_tag'], 100500));
        $this->assertEquals(100500, $data);
    }

    public function testGzip()
    {
        $key = 'test_gzip_0' . StringHandler::getRandomCode(10);
        $this->cacheManager->load((new CacheItemReference($key, [], $uncompressed = str_repeat('ZZ', 512)))->setOptions(CacheItemReference::OPTION_GZIP));
        $stored = $this->memcached->get($key);
        $this->assertEquals(CacheItem::FLAG_GZIP, $stored['flags']);
        $this->assertEquals($uncompressed, unserialize(gzdecode($stored['data'])));
    }

    public function testGzipFail()
    {
        $logger = $this->createMock(LoggerInterface::class);
        $cacheManager = new CacheManager(
            $this->memcached,
            $logger,
            new SimpleLeveledErrorReporter($logger),
            new StampedeProtector(),
            false,
        );

        $key = 'test_gzip_1' . StringHandler::getRandomCode(10);
        $this->memcached->set($key, $data = ['data' => gzencode(serialize('ABCEDFGHIJ')), 'flags' => CacheItem::FLAG_GZIP]);
        $this->assertEquals('ABCEDFGHIJ', $cacheManager->load(new CacheItemReference($key, [], 'new_data')));

        // malformed gzip
        $data['data'][3] = '_';
        $data['data'][4] = '_';
        $this->memcached->set($key, $data);
        $this->assertEquals('new_data', $cacheManager->load(new CacheItemReference($key, [], 'new_data')));
    }

    // TODO: stacked keys & logging test

    public function testGzipAuto()
    {
        $key = 'test_gzip_auto_0_' . StringHandler::getRandomCode(10);
        $this->cacheManager->load((new CacheItemReference($key, [], $uncompressed = str_repeat('Z', 200)))->setOptions(CacheItemReference::OPTION_GZIP_AUTO));
        $stored = $this->memcached->get($key);
        $this->assertEquals(0, $stored['flags']);
        $this->assertEquals($uncompressed, unserialize($this->memcached->get($key)['data']));

        [$key, $tags] = $this->getDefaultCacheItems('gzip_auto');

        $this->cacheManager->load((new CacheItemReference($key, $tags, $uncompressed = str_repeat('Z', 256)))->setOptions(CacheItemReference::OPTION_GZIP_AUTO));
        $stored = $this->memcached->get($key);
        $this->assertEquals(CacheItem::FLAG_GZIP, $stored['flags']);
        $this->assertEquals($uncompressed, unserialize(gzdecode($this->memcached->get($key)['data'])));

        $this->cacheManager->invalidateTags([$tags[0]], false);

        $this->cacheManager->load((new CacheItemReference($key, $tags, $uncompressed = str_repeat('Z', 10)))->setOptions(CacheItemReference::OPTION_GZIP_AUTO));
        $stored = $this->memcached->get($key);
        $this->assertEquals(0, $stored['flags']);
        $this->assertEquals($uncompressed, unserialize($this->memcached->get($key)['data']));
    }

    public function testMissingTags()
    {
        $suffix = StringHandler::getRandomCode(10);
        $key = 'test_missing_' . $suffix;
        $this->assertEquals(
            "a_b",
            $this->cacheManager->load(new CacheItemReference($key, ["a_" . $suffix, "b_" . $suffix], function () { return 'a_b'; }))
        );
        $this->assertEquals(
            "a_b_c",
            $this->cacheManager->load(new CacheItemReference($key, ["a_" . $suffix, "b_" . $suffix, "c_" . $suffix], function () { return 'a_b_c'; }))
        );
        $this->assertEquals(
            "a_b_c",
            $this->cacheManager->load(new CacheItemReference($key, ["a_" . $suffix, "b_" . $suffix, "c_" . $suffix], function () { return 'a_b_c_2'; }))
        );
        $this->assertEquals(
            "a_b_c",
            $this->cacheManager->load(new CacheItemReference($key, array_reverse(["a_" . $suffix, "b_" . $suffix, "c_" . $suffix]), function () { return 'a_b_c_3'; }))
        );
    }

    public function testLockWillHoldUntilReleasedOrTtl()
    {
        $clock = new ClockNative();
        $key = 'some_key_' . StringHandler::getRandomCode(10);
        $dataProviderInvocationCounter = 0;
        $cacheItemReference =
            (new CacheItemReference(
                $key,
                [],
                function () use (&$dataProviderInvocationCounter) {
                    $dataProviderInvocationCounter++;

                    return 100500;
                },
            ))
            ->setLockTtl(seconds(50));
        $competitorLock = new Lock(
            new Key('cache_lock_' . \substr($key, 10) . '_' . \hash('sha256', $key)),
            new MemcachedStore($this->memcached, 3),
            5,
            true
        );
        $competitorLock->acquire();
        $elapsed = $clock->stopwatch(fn () => $this->cacheManager->load($cacheItemReference));
        $this->assertGreaterThanOrEqual(4, $elapsed->getAsSecondsInt());
        $this->assertLessThan(10, $elapsed->getAsSecondsInt());
        $this->assertEquals(1, $dataProviderInvocationCounter);
    }

    public function testLockWillNotHoldOnAlreadyReleasedLock()
    {
        $clock = new ClockNative();
        $key = 'some_key_' . StringHandler::getRandomCode(10);
        $dataProviderInvocationCounter = 0;
        $cacheItemReference =
            (new CacheItemReference(
                $key,
                [],
                function () use (&$dataProviderInvocationCounter) {
                    $dataProviderInvocationCounter++;

                    return 100500;
                },
            ))
            ->setLockTtl(seconds(50));
        $competitorLock = new Lock(
            new Key('cache_lock_' . $key),
            new MemcachedStore($this->memcached, 3),
            5,
            true
        );
        $competitorLock->acquire();
        $competitorLock->release();
        $elapsed = $clock->stopwatch(fn () => $this->cacheManager->load($cacheItemReference));
        $this->assertLessThan(1, $elapsed->getAsSecondsInt());
        $this->assertEquals(1, $dataProviderInvocationCounter);
    }

    public static function shouldNotBeCalledCallback($error = '')
    {
        return function () use ($error) {
            throw new AssertionFailedError("This function should not be called. " . $error);
        };
    }

    protected function getDefaultCacheItems($testName, $tagsCount = 2)
    {
        $tags = [];

        for ($i = 0; $i < $tagsCount; $i++) {
            $tags[] = "tag_{$i}_{$testName}_" . StringHandler::getRandomCode(10);
        }

        $key = $testName . '_' . StringHandler::getRandomCode(10);

        $this->assertCacheResNotFound(array_merge($tags, [$key]));

        foreach ($tags as $tag) {
            $this->memcached->set($tag, 0);
        }

        return [$key, $tags];
    }

    protected function assertCacheResNotFound($keys)
    {
        $keys = (array) $keys;
        $this->assertNotEmpty($keys);
        $this->assertEmpty($this->memcached->getMulti($keys), 'Cache key is already set! Collision!!!');
    }
}

class FailOnSerialization
{
    public $payload = 0;

    public function __sleep()
    {
        throw new \Exception('sleep');
    }

    public function __wakeup()
    {
        call_user_func(CacheManagerTest::shouldNotBeCalledCallback('__wakeup call'));
    }
}

class FailOnDeserialization
{
    public $payload = 0;

    public function __sleep()
    {
        call_user_func(CacheManagerTest::shouldNotBeCalledCallback('__sleep call'));
    }

    public function __wakeup()
    {
        throw new \Exception('wakeup');
    }
}
