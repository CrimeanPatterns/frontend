Логика проверки extension v3 аккаунтов в мобильном приложении
========================================

Основные отличия от десктопной проверки
---------------------------------------------

Мобильное приложение должно переключиться в браузер для проверки v3. 
Мы минимизируем число переключений - объединяем все v3 аккаунты в группу 
  и переключаемся в браузер один раз, для проверки группы.

Алгоритм проверки
---------------------------------------------

- сервер: идем в лоялти и проверяем какие аккаунты из всех запрошенных для проверки будут проверяться через v3
  - <details><summary>[IMPL]</summary>
    
    в плагины прокидывается зависимость `ExtensionV3SupportLoader`, которая отвечает за хранение\обновление данных о том, какой аккаунт (на самом деле пара аккаунт+провайдер из (не)групповой проверки) будет проверяться через v3. В `ExtensionV3SupportLoader::loadV3SupportMap()` отправляются все account states, которые передали в плагин на тик, внутри происходит запрос на loyalty и cохраняется в стейт сессии апдейтера (сделано через ключ `ExtensionV3SupportMap` в опции `Option::EXTRA`, потом лучше переделать на нормальный стейт в сессии)
    </details>
- сервер: проверяем отсутствующие локальные пароли для v3 аккаунтов (`LocalPasswordPlugin`)
  - посылаем на мобильное событие "дай локальный пароль" для них. Одно событие для каждого аккаунта, как и было раньше.
  - ждем ввода всех локальных паролей для всех v3 аккаунтов, не отправляем на проверку v3 пока не обработаны все пароли
    - <details><summary>[IMPL]</summary>

      сохраняем время (с таймаутом 10 мин.) отправки ивента локального пароля в `LocalPasswordPlugin` через `ExtensionV3LocalPasswordWaitMapOps::addAccount()`. `ExtensionV3LocalPasswordWaitMapOps` хранит стейт в сессии апдейтера (сделано через опцию `InternalOptions::V3_LOCAL_PASSWORD_WAIT_MAP`, потом лучше переделать на нормальный стейт в сессии). Ждем ответа в `ClientCheckV3Plugin`, проверяем обработку всех паролей\таймауты через `ExtensionV3LocalPasswordWaitMapOps::hasActive`.
       </details>
  - нужно новое событие с клиента - отказ от ввода локального пароля. 
    - <details><summary>[IMPL]</summary>
      
      новое сообщение от клиента `refuseLocalPassword` обрабатывается в `AwardWallet\MainBundle\Updater\RequestHandler::handleUserMessages()` 
      </details>
  - так же надо решить сколько допустимо ждать ввода локального пароля. после достижения таймаута - считать что отказались давать пароль
    - <details><summary>[IMPL]</summary>10 минут (можно обсудить\поменять)</details>
- сервер: дождались паролей - посылаем в приложение событие "открой браузер для v3" 
  - <details><summary>[IMPL]</summary>

    `SwitchToBrowserEvent` посылается в `ServerCheckPlugin`, если это первый аккаунт в V3-группе.
    </details>
- приложение: получает событие "открой браузер для v3": 
  - записывает в стейт id текущей сессии апдейтера, и позицию в истории событий сессии, 
    чтобы восстановить ее если приложение убъют за время проверки в браузере. 
  - переключает в браузер с пробросом сессии и передачей подключения к старой centrifugo апдейтера (передает токен подключения к centrifugo).
      - <details><summary>[IMPL]</summary>
        
        - Внутри `SwitchToBrowserEvent` лежит токен, сгенерированный `EventsChannelMigrator`, который потом можно использовать на рауте миграции подключения к старой центрифуге (`/m/api/account/update2/migrate-events-channel`, доступен для анонимов). 
        - При создании токена `EventsChannelMigrator::send()` помещает в memcache по короткоживущему (5 минут) ключу (зависит от токена) значение с названием канала с ивентами от старой центрифуги. 
        - После отправки запроса с токеном из вкладки браузера на раут миграции, `EventsChannelMigrator::receive()` достает из memcache название канала старой центрифуги и помещает в PHP-сессию. 
        - Далее при подключении к старой центрифуге (`/centrifuge/auth/` теперь тоже доступный анонимам) внутри `UpdaterChannelAccessChecker::checkChannelAuth()` вызывается `EventsChannelMigrator::validate()`, который сравнивает название канала из PHP-сессии с тем, что передали в запросе. При любом исходе валидации из PHP-сессии удаляется название канала, а из мемкеша удаляется значение по ключу-токену. 
          </details>
    Как вариант можно сохранить токен подключения в сессиии, чтобы не передавать два параметра. 
    Мы передаем подключение к апдейтер сессии, чтобы читать из этой сессии extension v3 эвенты.
- сервер: отправляем события "проверка через v3", один аккаунт за другим, в один тред. их обрабатывает браузер.
  - <details><summary>[IMPL]</summary> 
    
    - "один за одним" сделано так: в `AccountState` записывается ключ `ExtensionV3startTime`, и каждый тик через `ClientCheckSlotsCalculator` проверяется сколько аккаунтов с таким ключом держится плагином на данный момент. Аналогично работало\работает в `ClientCheckLegacyPlugin` через ключ `startTime`. 
    - Ивент `ExtensionV3Event` посылается в `ServerCheckPlugin`, т.к. проверка инициируется запросом на loyalty, где занимает целый тред в воркере. 
    - Каждый V3-аккаунт из пачки записывается в список ожидания `ExtensionV3IsolatedCheckWaitMapOps::addAccount`. `ExtensionV3IsolatedCheckWaitMapOps` хранит стейт в сессии апдейтера (сделано через опцию `InternalOptions::V3_ISOLATED_CHECK_WAIT_MAP`, потом лучше переделать на нормальный стейт в сессии). 
    - На каждый вызов `AccountState::popPlugin()` и `MasterInterface::removeAccount()` в `ServerCheckPlugin` происходит удаление аккаунта из списка ожидания (`ExtensionV3IsolatedCheckWaitMapOps::removeAccount()`)
    </details>
- по окончаниии проверки пачки v3 - посылаем в браузер событие "переключи обратно в приложение"
  - <details><summary>[IMPL]</summary> 
    
    На каждое удаление из списка ожидания происходит проверка `ExtensionV3IsolatedCheckWaitMapOps::hasActive()`. Если список закончился, посылаем `SwitchFromBrowserEvent`
    </details> 
- приложение: получено переключение после проверки в браузере:
  - если уже было убито: восстанавливает id сессии апдейтера из стейта сохраненного перед переключением в браузер  
  - дочитывает события из сессии апдейтера, игнорируя события "проверка через v3", "переключи обратно в приложение"


Работа с группами провайдеров:
---------------------------------------------

Отличия от обычного поведения:

Если в группе первая проверка была серверная, а вторая v3, и это мобильное приложение -
то игнорировать вторую проверку в группе, не запускать ее. Так как это приведет
к повторному переключению в браузер.    


Работа с вопросами
-------------------

Вопросы в браузере не обрабатываются.
Вопросы будут обработаны в приложении позже, когда произойдет свитч в приложение.
Если приложение после ответа на вопрос добавит аккаунт снова в очередь, и этот аккаунт окажется v3 (был серверный),
то поведение не определено. Будет таймаут проверки либо серверная проверка, либо ошибка. Допустимо. 


